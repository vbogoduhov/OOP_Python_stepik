# Методы __setattr__, __getattribute__, __getattr__ и __delattr__

## ex. 3
### Объявите класс Book для представления информации о книге. 
Объекты этого класса должны создаваться командами:

```python
book = Book()
book = Book(название, автор, число страниц, год издания)
```

В каждом объекте класса _Book_ автоматически должны формироваться следующие локальные свойства:

**title** - заголовок книги (строка, по умолчанию пустая строка);

**author** - автор книги (строка, по умолчанию пустая строка);

**pages** - число страниц (целое число, по умолчанию 0);

**year** - год издания (целое число, по умолчанию 0).

Объявите в классе _Book_ магический метод ___setattr___ для проверки типов присваиваемых данных локальным свойствам _title_, _author_, _pages_ и _year_.
Если типы не соответствуют локальному атрибуту (например, _title_ должна ссылаться на строку, а _pages_ - на целое число), то генерировать исключение командой:

```python
raise TypeError("Неверный тип присваиваемых данных.")
```

Создайте в программе объект _book_ класса _Book_ для книги:

```python
автор: Сергей Балакирев
заголовок: Python ООП
pages: 123
year: 2022
```

## ex. 4
### Вы создаете интернет-магазин. 
Для этого нужно объявить два класса:

**Shop** - класс для управления магазином в целом;

**Product** - класс для представления отдельного товара.

Объекты класса _Shop_ следует создавать командой:

```python
shop = Shop(название магазина)
```

В каждом объекте класса _Shop_ должно создаваться локальное свойство:

_goods_ - список товаров (изначально список пустой).

А также в классе объявить методы:

**add_product(self, product)** - добавление нового товара в магазин (в конец списка _goods_);

**remove_product(self, product)** - удаление товара product из магазина (из списка _goods_);

Объекты класса _Product_ следует создавать командой:
```python
p = Product(название, вес, цена)
```

В них автоматически должны формироваться локальные атрибуты:

_id_ - уникальный идентификационный номер товара (генерируется автоматически как целое положительное число от 1 и далее);

_name_ - название товара (строка);

_weight_ - вес товара (целое или вещественное положительное число);

_price_ - цена (целое или вещественное положительное число).

В классе _Product_ через магические методы (подумайте какие) осуществить проверку на тип присваиваемых данных локальным атрибутам объектов класса (например, _id_ - целое число, _name- - строка и т.п.).
Если проверка не проходит, то генерировать исключение командой:
```python
raise TypeError("Неверный тип присваиваемых данных.")
```

Также в классе _Product_ с помощью магического(их) метода(ов) запретить удаление локального атрибута _id_.
При попытке это сделать генерировать исключение:
```python
raise AttributeError("Атрибут id удалять запрещено.")
```

Пример использования классов (в программе эти строчки не писать):

```python
shop = Shop("Балакирев и К")
book = Product("Python ООП", 100, 1024)
shop.add_product(book)
shop.add_product(Product("Python", 150, 512))
for p in shop.goods:
    print(f"{p.name}, {p.weight}, {p.price}")
```

## ex. 5
### Необходимо создать программу для обучающего курса. 
Для этого объявляются три класса:

**Course** - класс, отвечающий за управление курсом в целом;

**Module** - класс, описывающий один модуль (раздел) курса;

**LessonItem** - класс одного занятия (урока).


Объекты класса _LessonItem_ должны создаваться командой:
```python
lesson = LessonItem(название урока, число практических занятий, общая длительность урока)
```

Соответственно, в каждом объекте класса _LessonItem_ должны создаваться локальные атрибуты:

_title_ - название урока (строка);

_practices_ - число практических занятий (целое положительное число);

_duration_ - общая длительность урока (целое положительное число).

Необходимо с помощью магических методов реализовать следующую логику взаимодействия с объектами класса _LessonItem_:

1. Проверять тип присваиваемых данных локальным атрибутам. 
Если типы не соответствуют требованиям, то генерировать исключение командой:
    ```python
    raise TypeError("Неверный тип присваиваемых данных.")
    ```
2. При обращении к несуществующим атрибутам объектов класса _LessonItem_ возвращать значение _False_.
3. Запретить удаление атрибутов _title_, _practices_ и _duration_ в объектах класса _LessonItem_.

Объекты класса _Module_ должны создаваться командой:
```python
module = Module(название модуля)
```
Каждый объект класса _Module_ должен содержать локальные атрибуты:

_name_ - название модуля;

_lessons_ - список из уроков (объектов класса _LessonItem_), входящих в модуль (изначально список пуст).

Также в классе _Module_ должны быть реализованы методы:

**add_lesson(self, lesson)** - добавление в модуль (в конец списка _lessons_) нового урока (объекта класса _LessonItem_);

**remove_lesson(self, indx)** - удаление урока по индексу в списке _lessons_.

Наконец, объекты класса _Course_ создаются командой:
```python
course = Course(название курса)
```

И содержат следующие локальные атрибуты:

_name_ - название курса (строка);

_modules_ - список модулей в курсе (изначально список пуст).

Также в классе Course должны присутствовать следующие методы:

**add_module(self, module)** - добавление нового модуля в конце списка _modules_;

**remove_module(self, indx)** - удаление модуля из списка _modules_ по индексу в этом списке.

Пример использования классов (в программе эти строчки не писать):

```python
course = Course("Python ООП")
module_1 = Module("Часть первая")
module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
module_1.add_lesson(LessonItem("Урок 3", 5, 800))
course.add_module(module_1)
module_2 = Module("Часть вторая")
module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
course.add_module(module_2)
```

## ex. 6
### Вам необходимо написать программу описания музеев. 
Для этого нужно объявить класс _Museum_, объекты которого формируются командой:
```python
mus = Museum(название музея)
```
В объектах этого класса должны формироваться следующие локальные атрибуты:

_name_ - название музея (строка);

_exhibits_ - список экспонатов (изначально пустой список).

Сам класс _Museum_ должен иметь методы:

**add_exhibit(self, obj)** - добавление нового экспоната в музей (в конец списка _exhibits_);

**remove_exhibit(self, obj)** - удаление экспоната из музея (из списка _exhibits_ по ссылке _obj_ - на экспонат)

**get_info_exhibit(self, indx)** - получение информации об экспонате (строка) по индексу списка (нумерация с нуля).

Экспонаты представляются объектами своих классов. Для примера объявите в программе следующие классы экспонатов:

_Picture_ - для картин;

_Mummies_ - для мумий;

_Papyri_ - для папирусов.

Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):

```python
p = Picture(название, художник, описание)            # локальные атрибуты: name - название; author - художник; descr - описание
m = Mummies(имя мумии, место находки, описание)      # локальные атрибуты: name - имя мумии; location - место находки; descr - описание
pr = Papyri(название папируса, датировка, описание)  # локальные атрибуты: name - название папируса; date - датировка (строка); descr - описание
```
Метод _get_info_exhibit()_ класса Museum должен возвращать значение атрибута _descr_ указанного экспоната в формате:
```python
"Описание экспоната {name}: {descr}"
```

Например:

```"Описание экспоната Девятый вал: Айвазовский написал супер картину."```

Пример использования классов (в программе эти строчки писать не нужно - только для примера):

```python
mus = Museum("Эрмитаж")
mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор", "Вдохновляющая, устрашающая, волнующая картина"))
mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))
p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство о языках программирования")
mus.add_exhibit(p)
for x in mus.exhibits:
    print(x.descr)
```

## ex.7
### Объявите класс _SmartPhone_, объекты которого предполагается создавать командой:
```python
sm = SmartPhone(марка смартфона)
```

Каждый объект должен содержать локальные атрибуты:

_model_ - марка смартфона (строка);

_apps_ - список из установленных приложений (изначально пустой).

Также в классе _SmartPhone_ должны быть объявлены следующие методы:

**add_app(self, app)** - добавление нового приложения на смартфон (в конец списка _apps_);

**remove_app(self, app)** - удаление приложения по ссылке на объект _app_.

При добавлении нового приложения проверять, что оно отсутствует в списке _apps_ (отсутствует объект соответствующего класса).

Каждое приложение должно определяться своим классом. Для примера объявите следующие классы:

**AppVK** - класс приложения ВКонтаке;

**AppYouTube** - класс приложения YouTube;

**AppPhone** - класс приложения телефона.

Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):

```python
app_1 = AppVK() # name = "ВКонтакте"
app_2 = AppYouTube(1024) # name = "YouTube", memory_max = 1024
app_3 = AppPhone({"Балакирев": 1234567890, "Сергей": 98450647365, "Работа": 112}) # name = "Phone", phone_list = словарь с контактами
```
Пример использования классов (в программе эти строчки не писать):
```python
sm = SmartPhone("Honor 1.0")
sm.add_app(AppVK())
sm.add_app(AppVK())  # второй раз добавляться не должно
sm.add_app(AppYouTube(2048))
for a in sm.apps:
    print(a.name)
```

## ex. 8
### Объявите класс _Circle_ (окружность), объекты которого должны создаваться командой:
```python
circle = Circle(x, y, radius)   # x, y - координаты центра окружности; radius - радиус окружности
```

В каждом объекте класса _Circle_ должны формироваться локальные приватные атрибуты:

___x_, ___y_ - координаты центра окружности (вещественные или целые числа);

___radius_ - радиус окружности (вещественное или целое положительное число).


Для доступа к этим приватным атрибутам в классе _Circle_ следует объявить объекты-свойства (property):

**x**, **y** - для изменения и доступа к значениям ___x_, ___y_, соответственно;

**radius** - для изменения и доступа к значению ___radius_.

При изменении значений приватных атрибутов через объекты-свойства нужно проверять, 
что присваиваемые значения - числа (целые или вещественные). 
Дополнительно у радиуса проверять, что число должно быть положительным (строго больше нуля). 
Сделать все эти проверки нужно через магические методы. 
При некорректных переданных числовых значениях, прежние значения меняться не должны (исключений никаких генерировать при этом не нужно).

Если присваиваемое значение не числовое, то генерировать исключение командой:
```python
raise TypeError("Неверный тип присваиваемых данных.")
```

При обращении к несуществующему атрибуту объектов класса _Circle_ выдавать булево значение _False_.

Пример использования класса (эти строчки в программе писать не нужно):

```python
circle = Circle(10.5, 7, 22)
circle.radius = -10 # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
x, y = circle.x, circle.y
res = circle.name # False, т.к. атрибут name не существует
```
## ex. 9
### Объявите в программе класс _Dimensions_ (габариты) с атрибутами:

```python
MIN_DIMENSION = 10
MAX_DIMENSION = 1000
```

Каждый объект класса _Dimensions_ должен создаваться командой:
```python
d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
```
и содержать локальные атрибуты:

___a_, ___b_, ___c_ - габаритные размеры (целые или вещественные числа).


Для работы с этими локальными атрибутами в классе _Dimensions_ следует прописать следующие объекты-свойства:

_a_, _b_, _c_ - для изменения и считывания соответствующих локальных атрибутов ___a_, ___b_, ___c_.

При изменении значений ___a_, ___b_, ___c_ следует проверять, что присваиваемое значение число в диапазоне _[MIN_DIMENSION; MAX_DIMENSION]_. 
Если это не так, то новое значение не присваивается (игнорируется).

С помощью магических методов данного занятия запретить создание локальных атрибутов _MIN_DIMENSION_ и _MAX_DIMENSION_ в объектах класса _Dimensions_. 
При попытке это сделать генерировать исключение:
```python
raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
```

Пример использования класса  (эти строчки в программе писать не нужно):

```python
d = Dimensions(10.5, 20.1, 30)
d.a = 8
d.b = 15
a, b, c = d.a, d.b, d.c  # a=10.5, b=15, c=30
d.MAX_DIMENSION = 10  # исключение AttributeError
<<<<<<< HEAD
```
## ex. 10
### Объявите класс _GeyserClassic_ - фильтр для очистки воды. 
В этом классе должно быть три слота для фильтров. Каждый слот строго для своего класса фильтра:

_Mechanical_ - для очистки от крупных механических частиц;

_Aragon_ - для последующей очистки воды;

_Calcium_ - для обработки воды на третьем этапе.



Объекты классов фильтров должны создаваться командами:

```python
filter_1 = Mechanical(дата установки)
filter_2 = Aragon(дата установки)
filter_3 = Calcium(дата установки)
```

Во всех объектах этих классов должен формироваться локальный атрибут:

_date_ - дата установки фильтров (для простоты - положительное вещественное число).

Также нужно запретить изменение этого атрибута после создания объектов этих классов (только чтение). В случае присвоения нового значения, прежнее значение не менять. Ошибок никаких не генерировать.

Объекты класса _GeyserClassic_ должны создаваться командой:

```python 
g = GeyserClassic()
```

А сам класс иметь атрибут:

_MAX_DATE_FILTER_ = 100 - максимальное время работы фильтра (любого)

и следующие методы:

**add_filter(self, slot_num, filter)** - добавление фильтра _filter_ в указанный слот _slot_num_ (номер слота: 1, 2 и 3), если он (слот) пустой (без фильтра).
Также здесь следует проверять, что в первый слот можно установить только объекты класса _Mechanical_, 
во второй - объекты класса _Aragon_ и в третий - объекты класса _Calcium_. 
Иначе слот должен оставаться пустым.

**remove_filter(self, slot_num)** - извлечение фильтра из указанного слота (_slot_num_: 1, 2, и 3);

**get_filters(self)** - возвращает кортеж из набора трех фильтров в порядке их установки (по возрастанию номеров слотов);

**water_on(self)** - включение воды: возвращает _True_, если вода течет и _False_ - в противном случае.

Метод **water_on()** должен возвращать значение _True_ при выполнении следующих условий:

- все три фильтра установлены в слотах;
- все фильтры работают в пределах срока службы (значение (_time.time()_ - _date_) должно быть в пределах [0; MAX_DATE_FILTER])

Пример использования классов  (эти строчки в программе писать не нужно):

```python
my_water = GeyserClassic()
my_water.add_filter(1, Mechanical(time.time()))
my_water.add_filter(2, Aragon(time.time()))
w = my_water.water_on() # False
my_water.add_filter(3, Calcium(time.time()))
w = my_water.water_on() # True
f1, f2, f3 = my_water.get_filters()  # f1, f2, f3 - ссылки на соответствующие объекты классов фильтров
my_water.add_filter(3, Calcium(time.time())) # повторное добавление в занятый слот невозможно
my_water.add_filter(2, Calcium(time.time())) # добавление в "чужой" слот также невозможно
```
=======
```
