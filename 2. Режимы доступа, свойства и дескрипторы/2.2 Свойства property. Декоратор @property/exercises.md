# Свойства _property_. Декоратор @property

## ex. 4
### Объявите в программе класс _Car_, в котором реализуйте объект-свойство с именем _model_ для записи и считывания информации о модели автомобиля из локальной приватной переменной ___model_.

Объект-свойство объявите с помощью декоратора _@property_. Также в объекте-свойстве _model_ должны быть реализованы проверки:

- модель автомобиля - это строка;
- длина строки модели должна быть в диапазоне [2; 100].

Если проверка не проходит, то локальное свойство ___model_ остается без изменений.

Объекты класса _Car_ предполагается создавать командой:
```python
car = Car()
```
и далее работа с объектом-свойством, например:
```python
car.model = "Toyota"
```

## ex. 5
### Объявите в программе класс _WindowDlg_, объекты которого предполагается создавать командой:

```python
wnd = WindowDlg(заголовок окна, ширина, высота)
```

В каждом объекте класса _WindowDlg_ должны создаваться приватные локальные атрибуты:

**__title** - заголовок окна (строка);

**__width**, **__height** - ширина и высота окна (числа).

В классе _WindowDlg_ необходимо реализовать метод:

**show()** - для отображения окна на экране (выводит в консоль строку в формате: _"<Заголовок>: <ширина>, <высота>"_, например _"Диалог 1: 100, 50"_).

Также в классе _WindowDlg_ необходимо реализовать два объекта-свойства:

**width** - для изменения и считывания ширины окна;

**height** - для изменения и считывания высоты окна.

При изменении размеров окна необходимо выполнять проверку:

- переданное значение является целым числом в диапазоне [0; 10000].

Если хотя бы один размер изменился (высота или ширина), то следует выполнить автоматическую перерисовку окна (вызвать метод _show()_). 
При начальной инициализации размеров _width_, _height_ вызывать метод _show()_ не нужно.

## ex. 6
### Реализуйте односвязный список (не список Python, не использовать список Python для хранения объектов), когда один объект ссылается на следующий и так по цепочке до последнего:

Для этого объявите в программе два класса: 

**StackObj** - для описания объектов односвязного списка;

**Stack** - для управления односвязным списком.

Объекты класса _StackObj_ предполагается создавать командой:
```python
obj = StackObj(данные)
```

Здесь _данные_ - это строка с некоторым содержимым. Каждый объект класса _StackObj_ должен иметь следующие локальные приватные атрибуты:

**__data** - ссылка на строку с данными, указанными при создании объекта;

**__next** - ссылка на следующий объект класса _StackObj_ (при создании объекта принимает значение _None_).

Также в классе _StackObj_ должны быть объявлены объекты-свойства:

**next** - для записи и считывания информации из локального приватного свойства ___next_;

**data** - для записи и считывания информации из локального приватного свойства ___data_.

При записи необходимо реализовать проверку, что ___next_ будет ссылаться на объект класса _StackObj_ или значение _None_.
Если проверка не проходит, то ___next_ остается без изменений.

Класс _Stack_ предполагается использовать следующим образом:
```python
st = Stack() # создание объекта односвязного списка
```

В объектах класса _Stack_ должен быть локальный публичный атрибут:

**top** - ссылка на первый добавленный объект односвязного списка (если список пуст, то _top = None_).

А в самом классе _Stack_ следующие методы:

**push(self, obj)** - добавление объекта класса _StackObj_ в конец односвязного списка;

**pop(self)** - извлечение последнего объекта с его удалением из односвязного списка;

**get_data(self)** - получение списка из объектов односвязного списка (список из строк локального атрибута ___data_ каждого объекта в порядке их добавления, или пустой список, если объектов нет).

Пример использования классов _Stack_ и _StackObj_ (эти строчки в программе писать не нужно):

```python
st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st.pop()
res = st.get_data()    # ['obj1', 'obj2']
```

## ex. 7
### Объявите класс _RadiusVector2D_, объекты которого должны создаваться командами:

```python
v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
v3 = RadiusVector2D(1, 2)    # радиус-вектор с координатами (1; 2)
```

В каждом объекте класса _RadiusVector2D_ должны формироваться локальные приватные атрибуты:

**__x, __y** - координаты конца вектора (изначально значения равны 0, если не передано какое-либо другое).

В классе _RadiusVector2D_ необходимо объявить два объекта-свойства:

**x** - для изменения и считывания локального атрибута ___x_;

**y** - для изменения и считывания локального атрибута ___y_.

При инициализации и изменении локальных атрибутов, необходимо проверять корректность передаваемых значений:

- значение должно быть числом (целым или вещественным) в диапазоне _[MIN_COORD; MAX_COORD]_.

Если проверка не проходит, то координаты не меняются (напомню, что при инициализации они изначально равны 0). Величины _MIN_COORD = -100_, _MAX_COORD = 1024_ задаются как публичные атрибуты класса _RadiusVector2D_.

Также в классе _RadiusVector2D_ необходимо объявить статический метод:

**norm2(vector)** - для вычисления квадратической нормы _vector_ - переданного объекта класса _RadiusVector2D_ (квадратическая норма вектора: x^2 + y^2).

## ex. 8
### Требуется реализовать программу по работе с решающими деревьями:

Здесь в каждом узле дерева делается проверка (задается вопрос).
Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).

В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. 
Каждый элемент этого списка соответствует своему вопросу (своей вершине дерева).


Далее, этот вектор применяется к решающему дереву, следующим образом. 
Корневая вершина _"Любит Python"_ с ней связан первый элемент вектора _x_ и содержит значение 1, 
следовательно, мы переходим по левой ветви. Попадаем в вершину _"Понимает ООП"_. 
С ней связан второй элемент вектора _x_ со значением _0_, следовательно, мы переходим по правой ветви и попадаем в вершину _"будет кодером"_. 
Так как эта вершина конечная (листовая), то получаем результат в виде строки _"будет кодером"_. 
По аналогии выполняется обработка вектора _x_ с другими наборами значений _0_ и _1_.

Для реализации решающих деревьев в программе следует объявить два класса:

**TreeObj** - для описания вершин и листьев решающего дерева;

**DecisionTree** - для работы с решающим деревом в целом.

В классе _DecisionTree_ должны быть реализованы (по крайне мере) два метода уровня класса (_@classmethod_):

**def predict(cls, root, x)** - для построения прогноза (прохода по решающему дереву) для вектора _x_ из корневого узла дерева _root_.

**def add_obj(cls, obj, node=None, left=True)** - для добавления вершин в решающее дерево (метод должен возвращать добавленную вершину - объект класса _TreeObj_);

В методе _add_obj_ параметры имеют, следующие значения:

**obj** - ссылка на новый (добавляемый) объект решающего дерева (объект класса _TreeObj_);

**node** - ссылка на объект дерева, к которому присоединяется вершина _obj_;

**left** - флаг, определяющий ветвь дерева (объекта _node_), к которой присоединяется объект _obj_ (_True_ - к левой ветви; _False_ - к правой).

В классе _TreeObj_ следует объявить инициализатор:
```python
def __init__(self, indx, value=None):
```

где 
- _indx_ - проверяемый в вершине дерева индекс вектора _x_;

- _value_ - значение, хранящееся в вершине (принимает значение _None_ для вершин, у которых есть потомки - промежуточных вершин).

При этом, в каждом создаваемом объекте класса _TreeObj_ должны автоматически появляться следующие локальные атрибуты:

- _indx_ - проверяемый индекс (целое число);

- _value_ - значение с данными (строка);

- ___left_ - ссылка на следующий объект дерева по левой ветви (изначально _None_);
 
- ___right_ - ссылка на следующий объект дерева по правой ветви (изначально _None_).

Для работы с локальными приватными атрибутами ___left_ и ___right_ необходимо объявить объекты-свойства с именами _left_ и _right_.

Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):

```python
root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом
```

## ex. 9
### Вам требуется сформировать класс _PathLines_ для описания маршрутов, состоящих из линейных сегментов. 
При этом каждый линейный сегмент предполагается задавать отдельным классом _LineTo_. Объекты этого класса будут формироваться командой:
```python
line = LineTo(x, y)
```

где _x_, _y_ - следующая координата линейного участка (начало маршрута из точки 0, 0).

В каждом объекте класса _LineTo_ должны формироваться локальные атрибуты:

**x**, **y** - для хранения координат конца линии (начало определяется по координатам предыдущего объекта).

Объекты класса _PathLines_ должны создаваться командами:

```python
p = PathLines()                   # начало маршрута из точки 0, 0
p = PathLines(line1, line2, ...)  # начало маршрута из точки 0, 0
```
где _line1_, _line2_, ... - объекты класса _LineTo_.

Сам же класс _PathLines_ должен иметь следующие методы:

**get_path()** - возвращает список из объектов класса _LineTo_ (если объектов нет, то пустой список);

**get_length()** - возвращает суммарную длину пути (сумма длин всех линейных сегментов);

**add_line(self, line)** - добавление нового линейного сегмента (объекта класса _LineTo_) в конец маршрута.

Пояснение: суммарный маршрут - это сумма длин всех линейных сегментов, 
а длина каждого линейного сегмента определяется как евклидовое расстояние по формуле:

----
_L = sqrt((x1-x0)^2 + (y1-y0)^2)_

---

где _x0_, _y0_ - предыдущая точка маршрута; _x1_, _y1_ - текущая точка маршрута.

Пример использования классов (эти строчки в программе писать не нужно):

```python
p = PathLines(LineTo(10, 20), LineTo(10, 30))
p.add_line(LineTo(20, -10))
dist = p.get_length()
```
## ex. 10
### Вы создаете телефонную записную книжку. 
Она определяется классом _PhoneBook_. Объекты этого класса создаются командой:
```python
p = PhoneBook()
```

А сам класс должен иметь следующий набор методов:

**add_phone(phone)** - добавление нового номера телефона (в список);

**remove_phone(indx)** - удаление номера телефона по индексу списка;

**get_phone_list()** - получение списка из объектов всех телефонных номеров.

Каждый номер телефона должен быть представлен классом _PhoneNumber_. Объекты этого класса должны создаваться командой:
```python
note = PhoneNumber(number, fio)
```

где 
- _number_ - номер телефона (число) в формате _XXXXXXXXXXX_ (одиннадцати цифр, _X_ - цифра); 
- _fio_ - Ф.И.О. владельца номера (строка).

В каждом объекте класса _PhoneNumber_ должны формироваться локальные атрибуты:

_number_ - номер телефона (число);

_fio_ - ФИО владельца номера телефона.

Необходимо объявить два класса _PhoneBook_ и _PhoneNumber_ в соответствии с заданием.

Пример использования классов (эти строчки в программе писать не нужно):

```python
p = PhoneBook()
p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
p.add_phone(PhoneNumber(21345678901, "Панда"))
phones = p.get_phone_list()
```