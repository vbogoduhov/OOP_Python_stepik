# Методы __getitem__, __setitem__ и __delitem__

## ex_2
 ### Объявите класс _Record_ (запись), который описывает одну произвольную запись из БД. 

 Объекты этого класса создаются командой:

```Python
r = Record(field_name1=value1,... , field_nameN=valueN)
```

где _field_nameX_ - наименование поля БД; _valueX_ - значение поля из БД.

В каждом объекте класса _Record_ должны автоматически создаваться локальные публичные атрибуты 
по именам полей _(field_name1,... , field_nameN)_ с соответствующими значениями. 
Например:

```Python
r = Record(pk=1, title='Python ООП', author='Балакирев')
```

В объекте r появляются атрибуты:

```python
r.pk # 1
r.title # Python ООП
r.author # Балакирев
```

Также необходимо обеспечить доступ к этим полям (чтение/запись) через индексы следующим образом:

```python
r[0] = 2 # доступ к полю pk
r[1] = 'Супер курс по ООП' # доступ к полю title
r[2] = 'Балакирев С.М.' # доступ к полю author
print(r[1]) # Супер курс по ООП
r[3] # генерируется исключение IndexError
```

Если указывается неверный индекс (не целое число или некорректное целое число), то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс поля')
```

P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.

P.P.S. Для создания локальных атрибутов используйте коллекцию ___dict___ объекта класса _Record_.


## ex_3
### Вам необходимо для навигатора реализовать определение маршрутов. 
Для этого в программе нужно объявить класс _Track_, объекты которого создаются командой:

```python
tr = Track(start_x, start_y)
```

где _start_x_, _start_y_ - координата начала пути.

В этом классе должен быть реализован следующий метод:

**add_point(x, y, speed)** - добавление новой точки маршрута (линейный сегмент), 
который можно пройти со средней скоростью _speed_.

Также с объектами класса _Track_ должны выполняться команды:

```python
coord, speed = tr[indx] # получение координаты (кортеж с двумя числами) и скорости (число) для линейного сегмента маршрута с индексом indx
tr[indx] = speed # изменение средней скорости линейного участка маршрута по индексу indx
```

Если индекс _(indx)_ указан некорректно (должен быть целым числом от 0 до N-1, 
где _N_ - число линейных сегментов в маршруте), то генерируется исключение командой:

```python
raise IndexError('некорректный индекс')
```

Пример использования класса (эти строчки в программе не писать):

```python
tr = Track(10, -5.4)
tr.add_point(20, 0, 100) # первый линейный сегмент: indx = 0
tr.add_point(50, -20, 80) # второй линейный сегмент: indx = 1
tr.add_point(63.45, 1.24, 60.34) # третий линейный сегмент: indx = 2

tr[2] = 60
c, s = tr[2]
print(c, s)

res = tr[3] # IndexError
```

P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.

## ex_4
### Вам необходимо написать программу по работе с массивом однотипных данных (например, только числа или строки и т.п.). 
Для этого нужно объявить класс с именем _Array_, объекты которого создаются командой:

```python
ar = Array(max_length, cell)
```

где _max_length_ - максимальное количество элементов в массиве; 
_cell_ - ссылка на класс, описывающий отдельный элемент этого массива (см. далее, класс _Integer_). 
Начальные значения в ячейках массива (в объектах класса _Integer_) должны быть равны 0.

Для работы с целыми числами объявите в программе еще один класс с именем _Integer_, объекты которого создаются командой:

```python
cell = Integer(start_value)
```

где _start_value_ - начальное значение ячейки (в данном случае - целое число).

В классе _Integer_ должно быть следующее свойство (_property_):

**value** - для изменения и считывания значения из ячейки 
(само значение хранится в локальной приватной переменной; имя придумайте сами).

При попытке присвоить не целое число должно генерироваться исключение командой:

```python
raise ValueError('должно быть целое число')
```

Для обращения к отдельным элементам массива в классе _Array_
необходимо определить набор магических методов для следующих операций:

```python
value = ar[0] # получение значения из первого элемента (ячейки) массива ar
ar[1] = value # запись нового значения во вторую ячейку массива ar
```

Если индекс не целое число или число меньше нуля или больше либо равно _max_length_, 
то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс для доступа к элементам массива')
```

Пример использования классов (эти строчки в программе не писать):

```python
ar_int = Array(10, cell=Integer)
print(ar_int[3])
print(ar_int) # должны отображаться все значения массива в одну строчку через пробел
ar_int[1] = 10
ar_int[1] = 10.5 # должно генерироваться исключение ValueError
ar_int[10] = 1 # должно генерироваться исключение IndexError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

P.P.S. В качестве дополнительного домашнего задания: 
объявите еще один класс _Float_ для работы с вещественными числами и создайте массив, используя тот же класс _Array_, с этим новым типом данных.

## ex_5
### Вам необходимо написать программу для удобного обращения с таблицами однотипных данных (чисел, строк, булевых значений и т.п.), то есть, все ячейки таблицы должны представлять какой-то один указанный тип.

Для этого в программе необходимо объявить три класса:

**TableValues** - для работы с таблицей в целом;

**CellInteger** - для операций с целыми числами;

**IntegerValue** - дескриптор данных для работы с целыми числами.

Начнем с дескриптора _IntegerValue_. 

Это должен быть дескриптор данных (то есть, и для записи и считывания значений). 
Если присваиваемое значение не является целым числом, должно генерироваться исключение командой:

```python
raise ValueError('возможны только целочисленные значения')
```

Следующий класс _CellInteger_ описывает одну ячейку таблицы для работы с целыми числами.

В этом классе должен быть публичный атрибут (атрибут класса):

**value** - объект дескриптора, класса _IntegerValue_.

А объекты класса _CellInteger_ должны создаваться командой:

```python
cell = CellInteger(start_value)
```

где _start_value_ - начальное значение ячейки (по умолчанию равно 0 и сохраняется в ячейке через дескриптор _value_).

Наконец, объекты последнего класса _TableValues_ создаются командой:

```python
table = TableValues(rows, cols, cell=CellInteger)
```

где _rows, cols_ - число строк и столбцов (целые числа); 
_cell_ - ссылка на класс, описывающий работу с отдельными ячейками таблицы. 
Если параметр _cell_ не указан, то генерировать исключение командой:

```python
raise ValueError('параметр cell не указан')
```

Иначе, в объекте table класса _TableValues_ создается двумерный (вложенный) кортеж с именем _cells_ размером _rows x cols_, 
состоящий из объектов указанного класса (в данном примере - класса _CellInteger_).

Также в классе _TableValues_ предусмотреть возможность обращения к отдельной ячейке по ее индексам, например:

```python
value = table[1, 2] # возвращает значение ячейки с индексом (1, 2)
table[0, 0] = value # записывает новое значение в ячейку (0, 0)
```

Обратите внимание, по индексам сразу должно возвращаться значение ячейки, а не объект класса _CellInteger_. 

И то же самое с присваиванием нового значения.

Пример использования классов (эти строчки в программе не писать):

```python
table = TableValues(2, 3, cell=CellInteger)
print(table[0, 1])
table[1, 1] = 10
table[0, 0] = 1.45 # генерируется исключение ValueError

# вывод таблицы в консоль
for row in table.cells:
    for x in row:
        print(x.value, end=' ')
    print()
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

P.P.S. В качестве домашнего задания создайте класс _CellString_ для работы со строками и используйте тот же класс _TableValues_ для этого нового типа данных.

Последнее: дескрипторы здесь для повторения. В реальной разработке лучше использовать в таких задачах объекты-свойства (_property_).

## ex_6
### Ранее вы уже создавали стек-подобную структуру, когда один объект ссылается на следующий и так по цепочке до последнего:

Для этого в программе объявлялись два класса: 

**StackObj** - для описания объектов стека;

**Stack** - для управления стек-подобной структурой.

И, далее, объекты класса _StackObj_ следовало создавать командой:

```python
obj = StackObj(data)
```

где _data_ - это строка с некоторым содержимым объекта (данными).

При этом каждый объект класса _StackObj_ должен иметь следующие локальные атрибуты:

_data_ - ссылка на строку с данными, указанными при создании объекта;

_next_ - ссылка на следующий объект класса _StackObj_ (при создании объекта принимает значение _None_).

Класс _Stack_ предполагается использовать следующим образом:

```python
st = Stack() # создание объекта стек-подобной структуры
```

В каждом объекте класса _Stack_ должен быть локальный публичный атрибут:

_top_ - ссылка на первый объект стека (если стек пуст, то _top = None_).

А в самом классе _Stack_ следующие методы:

**push(self, obj)** - добавление объекта класса _StackObj_ в конец стека;

**pop(self)** - извлечение последнего объекта с его удалением из стека;

Дополнительно в классе _Stack_ нужно объявить магические методы для обращения к объекту стека по его индексу, например:

```python
obj_top = st[0] # получение первого объекта
obj = st[4] # получение 5-го объекта стека
st[2] = StackObj("obj3") # замена прежнего (3-го) объекта стека на новый
```

Если индекс не целое число или число меньше нуля или больше числа объектов в стеке, то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс')
```

Пример использования классов _Stack_ и _StackObj_ (эти строчки в программе не писать):

```python
st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st[1] = StackObj("new obj2")
print(st[2].data) # obj3
print(st[1].data) # new obj2
res = st[3] # исключение IndexError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
