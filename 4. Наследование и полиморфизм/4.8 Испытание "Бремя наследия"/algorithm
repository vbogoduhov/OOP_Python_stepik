Текстовое описание алгоритма:
1. Есть граф LinkedGraph с вершинами и связями.
2. Получаем матрицу смежности из графа.
3. Теперь нужно как-то обработать матрицу смжности.
3.1. Для обработки у нас есть начальная вершина, и конечная вершина.
3.2. Перед началом обработки создаём кортеж/множество для хранения просмотренных вершин.
     Создаём список с наименованием вершин и список со связями между этими вершинами.
     Необходимо создать список с весами для каждой вершины и обновлять его после каждой итерации.
      Это будет список для конкретного маршрута - то есть, для маршрута от стартовой вершины к конечной вершине.
     Необходима вспомогательная функция для выбора из списка непросмотренных вершин.
Разложим по иттерациям:
Матрица смежности - в нашем случае словарь:
{'1': [0, 1, 1, 4, inf, inf],
 '2': [1, 0, inf, inf, 5, inf],
 '3': [1, inf, 0, 2, inf, inf],
 '4': [4, inf, 2, 0, 2, 1],
 '5': [inf, 5, inf, 2, 0, 4],
 '6': [inf, inf, inf, 1, 4, 0]}

Иттерация №1:
Матрица смежности готова.
Множество просмотренных вершин содержит стартовую вершин, в данном случае - 1.
  {1}
Список с минимальными весами сформирован, туда добавлена стартовая вершина, таким образом он выглядит так:
  [0,inf,inf,inf,inf,inf]
Кортеж со списками вершин и связей
  ([1], [0])
Начинаем цикл:
  Получаем из матрицы смежности список связей/весов для стартовой вершины, по имени;
  Предполагаем, что индекс элемента списка совпадает с именем вершины,
  поэтому проверяем присутствует ли строкове представление индекса списка str(i) во множестве просмотренных вершин;
  Если да, то игнориуем вершину;
  Если нет, то прибавляем к значению веса текущей (стартовой) вершины значение веса просматриваемой (текущей) вершины;
  Проверяем, если значение веса для этой вершины меньше, чем было уже записано в списке, то меняем значение, если нет, то нет;
  Добавляем текущую вершину в список связанных, со стартовой, вершин;
  Получаем следующую вершину, из связных с текущей, с минимальным весом и не рассмотренную;
  У нас из нерасмотренных связных вершин с минимальным весом оказываются две - 2я и 3я. Начнём со второй
  Получаем следующую вершину - 2я и добавляем её во множество рассмотренных.
Результаты первой иттерации:
  {1, 2}
  [0, 1, 1, 4, inf, inf]
  ([1, 2], [0, 1])
Иттерация №2:
  Цикл:
    Получаем список связанных со 2й вершиной вершин и их весов - [1, 0, inf, inf, 5, inf];
    Проверяем первую вершину, находим её во множесте просмотренных и игнорируем;
    Проверяем следующие - 3 и 4 вершины, они не рассмотрены, но величина веса по ним равна бесконечности,
    как и было записано, поэтому значение не меняем.
    Проверяем 5ю вершину - она не рассмотрена, значение веса для неё будет равно - 6, что меньше предыдущего значения,
    поэтому меняем его. 
    Добавляем текущую вершину в список связанных.
    Для 6й вершины ничего не изменится.
    Получаем следующую вершину с минимальным весом из нерассмотренных - 3ю
    Добавляем её в списоке рассмотренных;
Результаты второй иттерации:
  {1, 2, 3}
  [0, 1, 1, 4, 5, inf]
  ([1, 2, 5], [0, 1, 5])
Иттерация №3:
  Цикл:
    Получаем список связанных с 3й вершиной вершин - [1, inf, 0, 2, inf, inf];
    При проверке будут игнорироваться вершины - 1, 2, 3, 5. 
    Следовательно для них значения минимальных весов не изменятся.
    Следующая вершина - 4я, будет рассмотрена. Значение минимального веса для неё изменится,
    так как старое значение 4 больше нового - 3.
    Вопрос - что делать теперь с добавлением вершины и связи для неё в список  маршрута????
    Потому как список с минимальными весами теперь равен - [0, 1, 1, 3, 5, inf]
    Получаем следующую вершину с минимальным весом среди нерассмотренных, это будет 4я вершина.
    Добавляем её в список рассмотренных.
Результаты третьей иттерации:
  {1, 2, 3, 4}
  [0, 1, 1, 3, 5, inf]
  ([1, 2,])
