# Наследование. Атрибуты private и protected

## ex_5
### Объявите класс _Animal_ (животное), объекты которого создаются командой:

```python
an = Animal(name, kind, old)
```

где _name_ - название животного (строка);

_kind_ - вид животного (строка);

_old_ - возраст (целое число).

В каждом объекте этого класса должны создаваться соответствующие приватные атрибуты: __name, __kind, __old.

В классе _Animal_ должны быть объявлены объекты-свойства для изменения и считывания приватных атрибутов:

**name** - для работы с приватным атрибутом __name;

**kind** - для работы с приватным атрибутом __kind;

**old** - для работы с приватным атрибутом __old.

Создайте в программе список с именем _animals_, который содержит три объекта класса _Animal_ со следующими данными:

```python
Васька; дворовый кот; 5
Рекс; немецкая овчарка; 8
Кеша; попугай; 3
```

P.S. В программе нужно объявить только класс и создать список animals. На экран выводить ничего не нужно.

## ex_6
### Объявите класс _Furniture_ (мебель), объекты которого создаются командой:

```python
f = Furniture(name, weight)
```

где _name_ - название предмета (строка);

_weight_ - вес предмета (целое или вещественное число).

В каждом объекте класса _Furniture_ должны создаваться защищенные локальные атрибуты с именами _name и _weight.

В самом классе _Furniture_ нужно объявить приватные методы:

**__verify_name()** - для проверки корректности имени;

**__verify_weight()** - для проверки корректности веса.

Метод **__verify_name()** проверяет, что имя должно быть строкой, если это не так, то генерируется исключение командой:

```python
raise TypeError('название должно быть строкой')
```

Метод **__verify_weight()** проверяет, что вес должен быть положительным числом (строго больше нуля), если это не так, то генерируется исключение командой:

```python
raise TypeError('вес должен быть положительным числом')
```

Данные методы следует вызывать всякий раз при записи новых значений в атрибуты __name_ и __weight_ (а также при их создании).

На основе базового класса _Furniture_ объявить следующие дочерние классы:

**Closet** - для представления шкафов;

**Chair** - для представления стульев;

**Table** - для представления столов.

Объекты этих классов должны создаваться командами:

```python
obj = Closet(name, weight, tp, doors)   # tp: True - шкаф-купе; False - обычный шкаф; doors - число дверей (целое число)
obj = Chair(name, weight, height)       # height - высота стула (любое положительное число)
obj = Table(name, weight, height, square) # height - высота стола; square - площадь поверхности (любые положительные числа)
```

В каждом объекте этих классов должны создаваться соответствующие защищенные атрибуты:

- в объектах класса **Closet**: __name_, __weight_, __tp_, __doors_

- в объектах класса **Chair**: __name_, __weight_, __height_

- в объектах класса **Table**: __name_, __weight_, __height_, __square_

В каждом классе (**Closet**, **Chair**, **Table**) объявить метод:

**get_attrs()**

который возвращает кортеж из значений локальных защищенных атрибутов объектов этих классов.

Пример использования классов (эти строчки в программе писать не нужно):

```python
cl = Closet('шкаф-купе', 342.56, True, 3)
chair = Chair('стул', 14, 55.6)
tb = Table('стол', 34.5, 75, 10)
print(tb.get_attrs())
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_7
### Своей работой вы немного впечатлили начальство и оно поручило вам доделать паттерн слушатель (_listener_).

Идея этого паттерна очень проста и основа реализуется следующим образом:

```python
class Observer:
    def update(self, data):
        pass

    def __hash__(self):
        return hash(id(self))


class Subject:
    def __init__(self):
        self.__observers = {}
        self.__data = None

    def add_observer(self, observer):
        self.__observers[observer] = observer

    def remove_observer(self, observer):
        if observer in self.__observers:
            self.__observers.pop(observer)

    def __notify_observer(self):
        for ob in self.__observers:
            ob.update(self.__data)

    def change_data(self, data):
        self.__data = data
        self.__notify_observer()
```

Здесь в объектах класса _Subject_ можно зарегистрировать (добавить) множество объектов класса _Observer_ (наблюдатель, слушатель).

Это делается с помощью метода **add_observer()**.

Затем, когда данные (_self.__data_) меняются путем вызова метода **change_data()** класса _Subject_,
то у всех слушателей автоматически вызывается метод **update()**.

В этом методе можно прописать самую разную логику работы при изменении данных в каждом конкретном слушателе.

В проекте данный паттерн предполагается использовать для отображения информации о погоде в различных форматах:

- текущая температура;
- текущее атмосферное давление;
- текущая влажность воздуха.

Для этого сами данные определяются классом:

```python
class Data:
    def __init__(self, temp, press, wet):
        self.temp = temp    # температура
        self.press = press  # давление
        self.wet = wet      # влажность
```

А вам поручается разработать дочерние классы, унаследованные от класса _Observer_, с именами:

**TemperatureView** - слушатель для отображения информации о температуре;

**PressureView** - слушатель для отображения информации о давлении;

**WetView** - слушатель для отображения информации о влажности.

Каждый из этих классов должен переопределять метод **update()** базового класса так, чтобы выводилась в консоль информация в формате:

```python
TemperatureView: "Текущая температура <число>"
PressureView: "Текущее давление <число>"
WetView: "Текущая влажность <число>"
```

Важно: для вывода информации в консоль используйте функцию **print()** с одним аргументом в виде F-строки.

Пример использования классов (эти строчки в программе писать не нужно):

```python
subject = Subject()
tv = TemperatureView()
pr = PressureView()
wet = WetView()

subject.add_observer(tv)
subject.add_observer(pr)
subject.add_observer(wet)

subject.change_data(Data(23, 150, 83))
# выведет строчки:
# Текущая температура 23
# Текущее давление 150
# Текущая влажность 83
subject.remove_observer(wet)
subject.change_data(Data(24, 148, 80))
# выведет строчки:
# Текущая температура 24
# Текущее давление 148
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_8
### Объявите базовый класс _Aircraft_ (самолет), объекты которого создаются командой:

```python
air = Aircraft(model, mass, speed, top)
```

где _model_ - модель самолета (строка);

_mass_ - подъемная масса самолета (любое положительное число);

_speed_ - максимальная скорость (любое положительное число);

_top_ - максимальная высота полета (любое положительное число).

В каждом объекте класса _Aircraft_ должны создаваться локальные атрибуты с именами: __model_, __mass_, __speed_, __top_ и соответствующими значениями.

Если передаваемые аргументы не соответствуют указанным критериям (строка, любое положительное число), то генерируется исключение командой:

```python
raise TypeError('неверный тип аргумента')
```

Далее, в программе объявите следующие дочерние классы:

**PassengerAircraft** - пассажирский самолет;

**WarPlane** - военный самолет.

Объекты этих классов создаются командами:

```python
pa = PassengerAircraft(model, mass, speed, top, chairs)  # chairs - число пассажирских мест (целое положительное число)
wp = WarPlane(model, mass, speed, top, weapons) # weapons - вооружение (словарь); ключи - название оружия, значение - количество
```

В каждом объекте классов _PassengerAircraft_ и _WarPlane_ должны формироваться локальные атрибуты с именами __chairs_ и __weapons_ соответственно.

Инициализация остальных атрибутов должна выполняться через инициализатор базового класса.

В инициализаторах классов _PassengerAircraft_ и _WarPlane_ проверять корректность передаваемых аргументов _chairs_ и _weapons_.

Если тип данных не совпадает, то генерировать исключение командой:

```python
raise TypeError('неверный тип аргумента')
```

Создайте в программе четыре объекта самолетов со следующими данными:

```python
PassengerAircraft: МС-21, 1250, 8000, 12000.5, 140
PassengerAircraft: SuperJet, 1145, 8640, 11034, 80
WarPlane: Миг-35, 7034, 25000, 2000, {"ракета": 4, "бомба": 10}
WarPlane: Су-35, 7034, 34000, 2400, {"ракета": 4, "бомба": 7}
```

Все эти объекты представить в виде списка _planes_.

P.S. В программе нужно объявить только классы и сформировать список На экран выводить ничего не нужно.

## ex_9
### Необходимо объявить функцию-декоратор _class_log_ для класса, которая бы создавала логирование вызовов методов класса.

Например следующие строчки программы:

```python
vector_log = []


@class_log(vector_log)
class Vector:
    def __init__(self, *args):
        self.__coords = list(args)

    def __getitem__(self, item):
        return self.__coords[item]

    def __setitem__(self, key, value):
        self.__coords[key] = value
```

декорируют класс _Vector_ и в список _vector_log_ добавляются имена методов, которые были вызваны при использовании этого класса.

В частности, после выполнения команд:

```python
v = Vector(1, 2, 3)
v[0] = 10
```

в списке _vector_log_ должны быть два метода:

```python
['__init__', '__setitem__']
```

Ваша задача реализовать декоратор с именем _class_log_.

Напоминание. Ранее вы уже создавали функцию-декоратор для класса следующим образом:

```python
def integer_params(cls):
    methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
    for k, v in methods.items():
        setattr(cls, k, integer_params_decorated(v))

    return cls
```

Используйте этот принцип для успешного прохождения подвига.

P.S. В программе нужно объявить только класс и необходимые функции. На экран выводить ничего не нужно.
