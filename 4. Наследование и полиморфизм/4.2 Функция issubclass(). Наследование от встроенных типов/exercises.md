# Функция _issubclass()_. Наследование от встроенных типов

## ex_3

### Создается проект, в котором предполагается использовать списки из целых чисел.

Для этого вам ставится задача создать класс с именем _ListInteger_ с базовым классом _list_ и переопределить три метода:

**__init__()**

**__setitem__()**

**append()**

так, чтобы список _ListInteger_ содержал только целые числа.

При попытке присвоить любой другой тип данных, генерировать исключение командой:

```pyth

raise TypeError('можно передавать только целочисленные значения')
```

Пример использования класса _ListInteger_ (эти строчки в программе не писать):

```pyth
s = ListInteger((1, 2, 3))
s[1] = 10
s.append(11)
print(s)
s[0] = 10.5 # TypeError
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_4
### Разрабатывается интернет-магазин.

Каждый товар предполагается представлять классом _Thing_, объекты которого создаются командой:

```pyth
thing = Thing(name, price, weight)
```

где _name_ - наименование товара (строка);

_price_ - цена (вещественное число);

_weight_ - вес товара (вещественное число).

В каждом объекте этого класса создаются аналогичные атрибуты: _name_, _price_, _weight_.

Класс _Thing_ необходимо определить так, чтобы его объекты можно было использовать в качестве ключей словаря, например:

```pyth
d = {}
d[thing] = thing
```

И для каждого уникального набора данных _name_, _price_, _weight_ должны формироваться свои уникальные ключи.

Затем, вам необходимо объявить класс словаря _DictShop_, унаследованный от базового класса _dict_.

В этом новом словаре ключами могут выступать только объекты класса _Thing_.

При попытке указать любой другой тип, генерировать исключение командой:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Объекты класса _DictShop_ должны создаваться командами:

```python
dict_things = DictShop() # пустой словарь
dict_things = DictShop(things) # словарь с набором словаря things
```

где _things_ - некоторый словарь.

В инициализаторе следует проверять, чтобы аргумент _thing_ был словарем, если не так, то выбрасывать исключение:

```python
raise TypeError('аргумент должен быть словарем')
```

И проверять, чтобы все ключи являлись объектами класса _Thing_.

Если это не так, то генерировать исключение:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Дополнительно в классе _DictShop_ переопределить метод:

```python
__setitem__()
```
с проверкой, что создаваемый ключ является объектом класса _Thing_.

Иначе, генерировать исключение:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Пример использования классов (эти строчки в программе не писать):

```python
th_1 = Thing('Лыжи', 11000, 1978.55)
th_2 = Thing('Книга', 1500, 256)
dict_things = DictShop()
dict_things[th_1] = th_1
dict_things[th_2] = th_2

for x in dict_things:
    print(x.name)

dict_things[1] = th_1 # исключение TypeError
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_5
### Объявите в программе следующие классы без содержимого (используйте оператор _pass_):

```python
Protists, Plants, Animals, Mosses, Flowering, Worms, Mammals, Human, Monkeys
```

и постройте схему наследования в соответствии со следующей иерархией древа жизни:

```
_здесь должна быть схема_
```

Затем, объявите в программе классы:

**Monkey** - наследуется от **Monkeys** и служит для описания обезьян;

**Person** - наследуется от **Human** и служит для описания человека;

**Flower** - наследуется от **Flowering** и служит для описания цветка;

**Worm** - наследуется от **Worms** и служит для описания червей.

Объекты этих классов должны создаваться командами:

```python
obj = Monkey(name, weight, old)
obj = Person(name, weight, old)
obj = Flower(name, weight, old)
obj = Worm(name, weight, old)
```

где _name_ - наименование (или имя) объекта (строка);

_weight_ - вес (вещественное число);

_old_ - возраст (целое число).

В каждом объекте любого из этих классов должны создаваться соответствующие атрибуты: _name_, _weight_, _old_.

Создайте в программе следующие объекты и сохраните их в виде списка _lst_objs_:

```python
Monkey: "мартышка", 30.4, 7
Monkey: "шимпанзе", 24.6, 8
Person: "Балакирев", 88, 34
Person: "Верховный жрец", 67.5, 45
Flower: "Тюльпан", 0.2, 1
Flower: "Роза", 0.1, 2
Worm: "червь", 0.01, 1
Worm: "червь 2", 0.02, 1
```

Затем, используя функции **isinstance()** и генератор списков (_List comprehensions_), сформируйте следующие списки из указанных объектов:

_lst_animals_ - все объекты, относящиеся к животным (**Animals**);

_lst_plants_ - все объекты, относящиеся к растениям (**Plants**);

_lst_mammals_ - все объекты, относящиеся к млекопитающим (**Mammals**).

P.S. В программе на экран выводить ничего не нужно.

## ex_6
### Известно, что с объектами класса _tuple_ можно складывать только такие же объекты (кортежи). Например:

```pyth
t1 = (1, 2, 3)
t2 = t1 + (4, 5) # (1, 2, 3, 4, 5)
```

Если же мы попытаемся прибавить любой другой итерируемый объект, например, список:

```pyth
t2 = t1 + [4, 5]
```

то возникнет ошибка.

Предлагается поправить этот функционал и создать свой собственный класс _Tuple_, унаследованный от базового класса _tuple_ и поддерживающий оператор:

```python
t1 = Tuple(iter_obj)
t2 = t1 + iter_obj  # создается новый объект класса Tuple с новым (соединенным) набором данных
```

где _iter_obj_ - любой итерируемый объект (список, словарь, строка, множество, кортеж и т.п.)

Пример использования класса (эти строчки в программе не писать):

```python
t = Tuple([1, 2, 3])
t = t + "Python"
print(t)   # (1, 2, 3, 'P', 'y', 't', 'h', 'o', 'n')
t = (t + "Python") + "ООП"
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.
