# 2.1 Режимы доступа public, private, protected. Сеттеры и геттеры
## ex. 3
**Объявите класс с именем _Clock_ и определите в нем следующие переменные и методы:**

- приватная локальная переменная _time_ для хранения текущего времени, целое число (своя для каждого объекта класса _Clock_ с начальным значением 0);
- публичный метод **set_time(tm)** для установки текущего времени (присваивает значение _tm_ приватному локальному свойству _time_, если метод _check_time(tm)_ возвратил _True_);
- публичный метод **get_time()** для получения текущего времени из приватной локальной переменной _time_;
- приватный метод класса **check_time(tm)** для проверки корректности времени в переменной _tm_ (возвращает _True_, если значение корректно и _False_ - в противном случае).

Проверка корректности выполняется по критерию: _tm_ должна быть целым числом, больше или равна нулю и меньше 100 000.

Объекты класса _Clock_ предполагается использовать командой:
```python
clock = Clock(время)

```
Создайте объект _clock_ класса _Clock_ и установите время, равным _4530_.
## ex. 4
**Объявите класс с именем _Money_ и определите в нем следующие переменные и методы:**

- приватная локальная переменная _money_ (целочисленная) для хранения количества денег (своя для каждого объекта класса _Money_);
- публичный метод **set_money(money)** для передачи нового значения приватной локальной переменной _money_ (изменение выполняется только если метод _check_money(money)_ возвращает значение _True_);
- публичный метод **get_money()** для получения текущего объема средств (денег);
- публичный метод **add_money(mn)** для прибавления средств из объекта _mn_ класса _Money_ к средствам текущего объекта;
- приватный метод класса **check_money(money)** для проверки корректности объема средств в параметре _money_ (возвращает _True_, если значение корректно и _False_ - в противном случае).

Проверка корректности выполняется по критерию: параметр _money_ должен быть целым числом, больше или равным нулю.
## ex. 6
**Объявите класс _Book_ со следующим набором сеттеров и геттеров:**

**set_title(self, title)** - запись в локальное приватное свойство ___title_ объектов класса _Book_ значения _title_;

**set_author(self, author)** - запись в локальное приватное свойство ___author_ объектов класса _Book_ значения _author_;

**set_price(self, price)** - запись в локальное приватное свойство ___price_ объектов класса _Book_ значения _price_;

**get_title(self)** - получение значения локального приватного свойства ___title_ объектов класса _Book_;

**get_author(self)** - получение значения локального приватного свойства ___author_ объектов класса _Book_;

**get_price(self)** - получение значения локального приватного свойства ___price_ объектов класса _Book_;

Объекты класса _Book_ предполагается создавать командой:
```python
book = Book(автор, название, цена)
```

При этом, в каждом объекте должны создаваться приватные локальные свойства:

- ___author_ - строка с именем автора;
- ___title_ - строка с названием книги;
- ___price_ - целое число с ценой книги.

## ex. 7
### Объявите класс _Line_ для описания линии на плоскости, объекты которого предполагается создавать командой:
```python
line = Line(x1, y1, x2, y2)
```
При этом в объекте _line_ должны создаваться следующие приватные локальные свойства:

**__x1, __y1** - начальная координата;

**__x2, __y2** - конечная координата.

В самом классе _Line_ должны быть реализованы следующие сеттеры и геттеры:

**set_coords(self, x1, y1, x2, y2)** - для изменения координат линии;

**get_coords(self)** - для получения кортежа из текущих координат линии.

А также метод:

**draw(self)** - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).

## ex. 8
### Объявите в программе два класса _Point_ и _Rectangle_. Объекты первого класса должны создаваться командой:
```python
pt = Point(x, y)
```
где _x_, _y_ - координаты точки на плоскости (целые или вещественные числа). 
При этом в объектах класса _Point_ должны формироваться следующие локальные свойства:

**__x, __y** - координаты точки на плоскости.

и один геттер:

**get_coords()** - возвращение кортежа текущих координат ___x_, ___y_

Объекты второго класса _Rectangle_ (прямоугольник) должны создаваться командами:
```python
r1 = Rectangle(Point(x1, y1), Point(x2, y2))
```

или
```python
r2 = Rectangle(x1, y1, x2, y2)
```

Здесь первая координата _(x1, y1)_ - верхний левый угол, а вторая координата _(x2, y2)_ - правый нижний. 
При этом, в объектах класса _Rectangle_ (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:

**__sp** - объект класса _Point_ с координатами _x1_, _y1_ (верхний левый угол);

**__ep** - объект класса _Point_ с координатами _x2_, _y2_ (нижний правый угол).

Также к классе _Rectangle_ должны быть реализованы следующие методы:

**set_coords(self, sp, ep)** - изменение текущих координат, где _sp_, _ep_ - объекты класса _Point_;

**get_coords(self)** - возвращение кортежа из объектов класса _Point_ с текущими координатами прямоугольника (ссылки на локальные свойства ___sp_ и ___ep_);

**draw(self)** - отображение в консоли сообщения: 
```python
"Прямоугольник с координатами: (x1, y1) (x2, y2)"
```
Здесь _x1_, _y1_, _x2_, _y2_ - соответствующие числовые значения координат.

Создайте объект _rect_ класса _Rectangle_ с координатами _(0, 0)_, _(20, 34)_.

## ex. 9
### Необходимо реализовать связный список (не список языка _Python_ и не хранить объекты в списке _Python_), когда объекты класса _ObjList_ связаны с соседними через приватные свойства ___next_ и ___prev_:

Для этого объявите класс _LinkedList_, который будет представлять связный список в целом и иметь набор следующих методов:

**add_obj(self, obj)** - добавление нового объекта _obj_ класса _ObjList_ в конец связного списка;

**remove_obj(self)** - удаление последнего объекта из связного списка;

**get_data(self)** - получение списка из строк локального свойства ___data_ всех объектов связного списка.

И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:

**head** - ссылка на первый объект связного списка (если список пустой, то _head = None_);

**tail** - ссылка на последний объект связного списка (если список пустой, то _tail = None_).

Объекты класса _ObjList_ должны иметь следующий набор приватных локальных свойств:

**__next** - ссылка на следующий объект связного списка (если следующего объекта нет, то ___next = None_);

**__prev** - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то ___prev = None_);

**__data** - строка с данными.

Также в классе _ObjList_ должны быть реализованы следующие сеттеры и геттеры:

**set_next(self, obj)** - изменение приватного свойства ___next_ на значение _obj_;

**set_prev(self, obj)** - изменение приватного свойства ___prev_ на значение _obj_;

**get_next(self)** - получение значения приватного свойства ___next_;

**get_prev(self)** - получение значения приватного свойства ___prev_;

**set_data(self, data)__ - изменение приватного свойства ___data_ на значение _data_;

**get_data(self)** - получение значения приватного свойства ___data_.


Создавать объекты класса _ObjList_ предполагается командой:
```python
ob = ObjList("данные 1")
```

А использовать класс _LinkedList_ следующим образом (пример, эти строчки писать в программе не нужно):
```python
lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
```

Объявите в программе классы _LinkedList_ и _ObjList_ в соответствии с заданием.

## ex. 10
### Объявите класс _EmailValidator_ для проверки корректности email-адреса. 

Необходимо запретить создание объектов этого класса: при создании экземпляров должно возвращаться значение _None_, например:
```python
em = EmailValidator() # None
```

В самом классе реализовать следующие методы класса (_@classmethod_):

**get_random_email(cls)** - для генерации случайного email-адреса по формату: _xxxxxxx...xxx@gmail.com_, 
где _x_ - любой допустимый символ в _email_ (латинский буквы, цифры, символ подчеркивания и точка);

**check_email(cls, email)** - возвращает _True_, если _email_ записан верно и _False_ - в противном случае.

Корректность строки _email_ определяется по следующим критериям:

- допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка _@_ (одна);
- длина _email_ до символа _@_ не должна превышать 100 (сто включительно);
- длина _email_ после символа _@_ не должна быть больше 50 (включительно);
- после символа _@_ обязательно должна идти хотя бы одна точка;
- не должно быть двух точек подряд.

Также в классе нужно реализовать приватный статический метод класса:

**is_email_str(email)** - для проверки типа переменной _email_, если строка, то возвращается значение _True_, иначе - _False_.

Метод _is_email_str()_ следует использовать в методе _check_email()_ перед проверкой корректности _email_. 
Если параметр _email_ не является строкой, то _check_email()_ возвращает _False_.

Пример использования класса _EmailValidator_ (эти строчки в программе писать не нужно):

```python
res = EmailValidator.check_email("sc_lib@list.ru") # True
res = EmailValidator.check_email("sc_lib@list_ru") # False
```
