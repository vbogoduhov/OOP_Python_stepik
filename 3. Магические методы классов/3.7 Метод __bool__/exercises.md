# Метод __bool__

## ex_4

## Объявите в программе класс Player (игрок), объекты которого создаются командой:

```python
player = Player(name, old, score)
```

где _name_ - имя игрока (строка); 

_old_ - возраст игрока (целое число); 

_score_ - набранные очки в игре (целое число). 

В каждом объекте класса _Player_ должны создаваться аналогичные локальные атрибуты: _name_, _old_, _score_.

С объектами класса _Player_ должна работать функция:

```python
bool(player)
```

которая возвращает _True_, если число очков больше нуля, и _False_ - в противном случае.

С помощью команды:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

считываются строки из входного потока в список строк _lst_in_. 

Каждая строка записана в формате:

_"имя; возраст; очки"_

Например:

```python
Балакирев; 34; 2048
Mediel; 27; 0
Влад; 18; 9012
Nina P; 33; 0
```

Каждую строку списка _lst_in_ необходимо представить в виде объекта класса _Player_ с соответствующими данными. 
И из этих объектов сформировать список _players_.

Отфильтруйте этот список (создайте новый: _players_filtered_), оставив всех игроков с числом очков больше нуля. 
Используйте для этого стандартную функцию _filter()_ совместно с функцией _bool()_ языка _Python_.


P.S. На экран ничего выводить не нужно.

## ex_5
### Объявите в программе класс _MailBox_ (почтовый ящик), объекты которого создаются командой:

```python
mail = MailBox()
```

Каждый объект этого класса должен содержать локальный публичный атрибут:

_inbox_list_ - список из принятых писем.

Также в классе _MailBox_ должен присутствовать метод:

```python
receive(self) - прием новых писем
```

Этот метод должен читать данные из входного потока командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

В результате формируется список _lst_in_ из строк. Каждая строка записана в формате:

```python
"от кого; заголовок; текст письма"
```

Например:

```python
sc_lib@list.ru; От Балакирева; Успехов в IT!
mail@list.ru; Выгодное предложение; Вам одобрен кредит.
mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
```

Каждая строчка списка _lst_in_ должна быть представлена объектом класса _MailItem_, объекты которого создаются командой:

```python
item = MailItem(mail_from, title, content)
```

где _mail_from_ - email отправителя (строка);

_title_ - заголовок письма (строка), 

_content_ - содержимое письма (строка). 

В каждом объекте класса _MailItem_ должны формироваться соответствующие локальные атрибуты (с именами: _mail_from_, _title_, _content_).\
И дополнительно атрибут _is_read_ (прочитано ли) с начальным значением _False_.

В классе _MailItem_ должен быть реализован метод:

**set_read(self, fl_read)** - для отметки, что письмо прочитано (метод должен устанавливать атрибут _is_read = fl_read_, если _True_, то письмо прочитано, если _False_, то не прочитано).

С каждым объектом класса _MailItem_ должна работать функция:

```python
bool(item)
```

которая возвращает _True_ для прочитанного письма и _False_ для непрочитанного.

Вызовите метод:

```python
mail.receive()
```

Отметьте первое и последнее письмо в списке _mail.inbox_list_, как прочитанное (используйте для этого метод _set_read_). 
Затем, сформируйте в программе список (глобальный) с именем _inbox_list_filtered_ из прочитанных писем, используя стандартную функцию _filter()_score_ совместно с функцией _bool()_ языка _Python_.

P.S. На экран ничего выводить не нужно.

## ex_6
### Объявите класс _Line_, объекты которого создаются командой:

```python
line = Line(x1, y1, x2, y2)
```

где _x1_, _y1_, _x2_, _y2_ - координаты начала линии _(x1, y1)_ и координаты конца линии _(x2, y2)_.

Могут быть произвольными числами. 

В объектах класса _Line_ должны создаваться соответствующие локальные атрибуты с именами _x1_, _y1_, _x2_, _y2_.

В классе _Line_ определить магический метод ___len___() так, чтобы функция:

```python
bool(line)
```

возвращала _False_, если длина линии меньше 1.

P.S. На экран ничего выводить не нужно. Только объявить класс.

## ex_7
### Объявите класс _Ellipse_ (эллипс), объекты которого создаются командами:

```python
el1 = Ellipse()  # без создания локальных атрибутов x1, y1, x2, y2
el2 = Ellipse(x1, y1, x2, y2)
```

где _x1_, _y1_ - координаты (числа) левого верхнего угла; 

_x2_, _y2_ - координаты (числа) нижнего правого угла. 

Первая команда создает объект класса _Ellipse_ без локальных атрибутов _x1_, _y1_, _x2_, _y2_. 
Вторая команда создает объект с локальными атрибутами _x1_, _y1_, _x2_, _y2_ и соответствующими переданными значениями.

В классе _Ellipse_ объявите магический метод ___bool___(), который бы возвращал _True_, если все локальные атрибуты _x1_, _y1_, _x2_, _y2_ существуют и _False_ - в противном случае.

Также в классе _Ellipse_ нужно реализовать метод:

**get_coords()** - для получения кортежа текущих координат объекта.

Если координаты отсутствуют (нет локальных атрибутов _x1_, _y1_, _x2_, _y2_), то метод **get_coords()** должен генерировать исключение командой:

```python
raise AttributeError('нет координат для извлечения')
```

Сформируйте в программе список с именем _lst_geom_, содержащий четыре объекта класса _Ellipse_. 
Два объекта должны быть созданы командой 

```python
Ellipse()
```

и еще два - командой:

```python
Ellipse(x1, y1, x2, y2)
```

Переберите список в цикле и вызовите метод **get_coords()** только для объектов, имеющих координаты _x1_, _y1_, _x2_, _y2_. 
(Помните, что для этого был определен магический метод ___bool___()).

P.S. На экран ничего выводить не нужно.
## ex_8
Вы начинаете разрабатывать игру "Сапер". Для этого вам нужно уметь представлять и управлять игровым полем. Будем полагать, что оно имеет размеры N x M клеток. Каждая клетка будет представлена объектом класса Cell и содержать либо число мин вокруг этой клетки, либо саму мину.



Для начала в программе объявите класс GamePole, который будет создавать и управлять игровым полем. Объект этого класса должен формироваться командой:

pole = GamePole(N, M, total_mines)
И, так как поле в игре одно, то нужно контролировать создание только одного объекта класса GamePole (используйте паттерн Singleton, о котором мы с вами говорили, когда рассматривали магический метод __new__()).

Объект pole должен иметь локальный приватный атрибут:

__pole_cells - двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов), состоящий из объектов класса Cell.

Для доступа к этой коллекции объявите в классе GamePole объект-свойство (property):

pole - только для чтения (получения) ссылки на коллекцию __pole_cells.

Далее, в самом классе GamePole объявите следующие методы:

init_pole() - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);
open_cell(i, j) - открывает ячейку с индексами (i, j); нумерация индексов начинается с нуля; метод меняет значение атрибута __is_open объекта Cell в ячейке (i, j) на True;
show_pole() - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее задание).

Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint модуля random). После расстановки всех total_mines мин, вычислите их количество вокруг остальных клеток (где нет мин). Область охвата - соседние (прилегающие) клетки (8 штук).

В методе open_cell() необходимо проверять корректность индексов (i, j). Если индексы указаны некорректно, то генерируется исключение командой:

raise IndexError('некорректные индексы i, j клетки игрового поля')
Следующий класс Cell описывает состояние одной ячейки игрового поля. Объекты этого класса создаются командой:

cell = Cell()
При этом в самом объекте создаются следующие локальные приватные свойства:

__is_mine - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
__number - число мин вокруг клетки (целое число от 0 до 8);
__is_open - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.

Для работы с этими приватными атрибутами объявите в классе Cell следующие объекты-свойства с именами:

is_mine - для записи и чтения информации из атрибута __is_mine;
number - для записи и чтения информации из атрибута __number;
is_open - для записи и чтения информации из атрибута __is_open.

В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение True/False, либо целое число от 0 до 8). Если передаваемое значение некорректно, то генерировать исключение командой:

raise ValueError("недопустимое значение атрибута")
С объектами класса Cell должна работать функция:

bool(cell)
которая возвращает True, если клетка закрыта и False - если открыта.

Пример использования классов (эти строчки в программе писать не нужно):

pole = GamePole(10, 20, 10)  # создается поле размерами 10x20 с общим числом мин 10
pole.init_pole()
if pole.pole[0][1]:
    pole.open_cell(0, 1)
if pole.pole[3][5]:
    pole.open_cell(3, 5)
pole.open_cell(30, 100)  # генерируется исключение IndexError
pole.show_pole()
P.S. В программе на экран выводить ничего не нужно, только объявить классы.
