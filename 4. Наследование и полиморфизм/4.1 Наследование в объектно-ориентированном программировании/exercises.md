# Наследование в объектно-ориентированном программировании
## ex_4
### Наследование часто используют, чтобы вынести общий код дочерних классов в базовый класс.

Сделаем такой пример. Объявите в программе базовый класс _Animal_ (животное), объекты которого можно создать командой:

```python
an = Animal(name, old)
```

где _name_ - название животного (строка); 
_old_ - возраст животного (целое число). 

Такие же локальные атрибуты (_name_ и _old_) должны создаваться в объектах класса.

Далее, объявите дочерний класс (от базового _Animal_) с именем _Cat_ (кошки), объекты которого создаются командой:

```python
cat = Cat(name, old, color, weight)
```

где _name_, _old_ - те же самые параметры, что и в базовом классе; 

_color_ - цвет кошки (строка); 

_weight_ - вес кошки (любое положительное число).

В объектах класса _Cat_ должны автоматически формироваться локальные атрибуты: _name_, _old_, _color_, _weight_. 

Формирование атрибутов _name_, _old_ должен выполнять инициализатор базового класса. 

По аналогии объявите еще один дочерний класс _Dog_ (собака), объекты которого создаются командой:

```python
dog = Dog(name, old, breed, size)
```

здесь _name_, _old_ - те же самые параметры, что и в базовом классе;

_breed_ - порода собаки (строка);

_size_ - кортеж в формате (_height_, _length_) высота и длина - числа.

В объектах класса _Dog_ по аналогии должны формироваться локальные атрибуты: _name_, _old_, _breed_, _size_.

За формирование атрибутов _name_, _old_ отвечает инициализатор базового класса.

Наконец, в классах _Cat_ и _Dog_ объявите метод:

**get_info()** - для получения информации о животном.

Этот метод должен возвращать строку в формате:

```python
"name: old, <остальные параметры через запятую>"
```

Например, для следующего объекта класса _Cat_:

```python
cat = Cat('кот', 4, 'black', 2.25)
```

метод _get_info_ должен вернуть строку:

```python
"кот: 4, black, 2.25"
```

P.S. В программе достаточно объявить три класса. Выводить на экран ничего не нужно.

## ex_5
### Иногда наследование используют, чтобы наделить объекты дочерних классов определенным набором атрибутов. 

Сделаем такой пример.

Предположим, вы разрабатываете программу для интернет-магазина.
В этом магазине могут быть как реальные (физические) товары, так и электронные.
Для этих двух групп, очевидно, нужен разный набор атрибутов:

- для реальных физических товаров: _id_, _name_, _price_, _weight_, _dims_

где _id_ - идентификатор товара (целое число);

_name_ - наименование товара (строка);

_price_ - цена товара (вещественное число); 

_weight_ - вес товара (вещественное число); 

_dims_ = _(lenght, width, depth)_ - длина, ширина, глубина - габариты товара (вещественные числа);

- для электронных товаров: _id_, _name_, _price_, _memory_, _frm_

где _id_ - идентификатор товара (целое число); 

_name_ - наименование товара (строка); 

_price_ - цена товара (вещественное число); 

_memory_ - занимаемый размер (в байтах - целое число); 

_frm_ - формат данных (строка: _pdf_, _docx_ и т.п.)

Так как все товары могут идти вперемешку, то мы хотим, чтобы в каждом объекте (для товара) присутствовали все атрибуты:

```python
id, name, price, weight, dims, memory, frm
```

с начальными значениями _None_. 

А уже, затем, нужным из них будут присвоены конкретные данные.

Для реализации этой логики объявите в программе базовый класс с именем _Thing_ (вещь, предмет), объекты которого могут создаваться командой:

```python
th = Thing(name, price)
```

А атрибут _id_ должен формироваться автоматически и быть уникальным для каждого товара (например, можно для каждого нового объекта увеличивать на единицу).

В объектах класса _Thing_ должен формироваться полный набор локальных атрибутов (_id_, _name_, _price_, _weight_, _dims_, _memory_, _frm_) со значением _None_, кроме атрибутов: _id_, _name_, _price_.

Далее, нужно объявить два дочерних класса:

**Table** - для столов;

**ElBook** - для электронных книг.

Объекты этих классов должны создаваться командами:

```python
table = Table(name, price, weight, dims)
book = ElBook(name, price, memory, frm)
```


Причем, атрибуты _name_, _price_ (а также _id_) следует инициализировать в базовом классе, т.к. они общие для всех товаров. 

Остальные атрибуты должны либо принимать значение _None_, если не используются, либо инициализироваться конкретными значениями уже в дочерних классах.

Наконец, в базовом классе _Thing_ объявите метод:

**get_data()** - для получения кортежа в формате (_id_, _name_, _price_, _weight_, _dims_, _memory_, _frm_)

Пример использования классов (эти строчки в программе писать не нужно):

```python
table = Table("Круглый", 1024, 812.55, (700, 750, 700))
book = ElBook("Python ООП", 2000, 2048, 'pdf')
print(*table.get_data())
print(*book.get_data())
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


## ex_6
### Еще один пример, когда в базовом классе прописывается необходимый начальный функционал для дочерних классов.

Известно, что браузер (и не только) может отправлять на сервер различные типы запросов: _GET_, _POST_, _PUT_, _DELETE_ и др.

Каждый из этих типов запросов обрабатывается в программе на сервере своим отдельным методом.

Чтобы каждый раз не прописывать все необходимые методы в классах при обработке входящих запросов, они выносятся в базовый класс и вызываются из дочерних.

Выполним такой пример.

Пусть в программе объявлен следующий базовый класс с именем _GenericView_:

```python
class GenericView:
    def __init__(self, methods=('GET',)):
        self.methods = methods

    def get(self, request):
        return ""

    def post(self, request):
        pass

    def put(self, request):
        pass

    def delete(self, request):
        pass
```

Здесь каждый метод отвечает за обработку своего типа запроса.

Параметр _methods_ - это кортеж или список, состоящий из набора разрешенных запросов:

строк с именами соответствующих методов (как правило, пишут заглавными буквами).

Вам необходимо объявить дочерний класс с именем _DetailView_, объекты которого можно создавать командами:

```python
dv = DetailView()  # по умолчанию methods=('GET',)
dv = DetailView(methods=('PUT', 'POST'))
```

Для инициализации атрибута _methods_ следует вызывать инициализатор базового класса _GenericView_.

Далее, в классе _DetailView_ нужно определить метод:

```python
def render_request(self, request, method): ...
```

который бы имитировал выполнение поступившего на сервер запроса.

Здесь _request_ - словарь с набором данных запроса;

_method_ - тип запроса (строка: _'get'_ или _'post'_ и т.д.).

Например:

```python
html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')
```

должен быть обработан запрос как _GET_-запрос с параметром _url_ и значением _'https://site.ru/home'_.

Параметр _url_ является обязательным в словаре _request_ для каждого запроса.

В методе _render_request()_ необходимо выполнить проверку: является ли указанный метод (_method_) разрешенным (присутствует в коллекции _methods_).

Если это не так, то генерировать исключение командой:

```python
raise TypeError('данный запрос не может быть выполнен')
```

Если проверка проходит, то выполнить соответствующий метод (или **get()**, или **post()**, или **put()** и т.д. с возвращением результата их работы). 

Подсказка: для получения ссылки на нужный метод можно воспользоваться магическим методом ___getattribute___() или аналогичной функцией _getattr()_).

Наконец, в дочернем классе _DetailView_ следует переопределить метод _get()_ для нужной нам обработки _GET_-запросов.

В этом методе нужно выполнить проверку, что параметр request является словарем.

Если это не так, то генерировать исключение:

```python
raise TypeError('request не является словарем')
```

Сделать проверку, что в словаре _request_ присутствует ключ _url_. 

Если его нет, то генерировать исключение:

```python
raise TypeError('request не содержит обязательного ключа url')
```

Если же все проверки проходят, то вернуть строку в формате:

```python
"url: <request['url']>"
```

Пример (эти строчки в программе писать не нужно):

```python
dv = DetailView()
html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')   # url: https://site.ru/home
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_7
### С помощью наследования можно как бы "наполнять" дочерние классы нужными качествами (свойствами).

Как пример, объявите в программе класс с именем:

```python
Singleton
```

который бы позволял создавать только один экземпляр (все последующие экземпляры должны ссылаться на первый).

Как это делать, вы должны уже знать из этого курса.

Затем, объявите еще один класс с именем:

```python
Game
```

который бы наследовался от класса _Singleton_. Объекты класса Game должны создаваться командой:

```python
game = Game(name)
```

где _name _- название игры (строка).

В каждом объекте класса Game должен создаваться атрибут name с соответствующим содержимым.

Убедитесь, что атрибут _name_ принимает значение первого созданного объекта (если это не так, то поправьте инициализатор дочернего класса, чтобы это условие выполнялось).

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_8
### Вам необходимо создать множество классов для валидации (проверки) корректности данных.

Для этого ваш непосредственный начальник (Senior) предлагает вам объявить в программе базовый класс с именем:

```python
Validator
```

обеспечивающий базовый функционал для проверки корректности данных.

В частности, в этом классе нужно объявить следующий метод:

```python
def _is_valid(self, data): ...
```

По задумке этот метод должен возвращать булево значение _True_, если данные (_data_) корректны и _False_ - в противном случае.

Так как базовый класс _Validator_ - это общий класс для всех видов проверок, то метод __is_valid()_ будет просто возвращать _True_.
Кроме того, объекты класса _Validator_:

```python
v = Validator()   # инициализатор в классе Validator прописывать не нужно
```

должны вызываться подобно функциям:

```python
v(data)
```

Если значение _data_ корректно, то оно возвращается, иначе генерируется исключение:

Проверка корректности выполняется с помощью метода __is_valid()_. 

После этого, в программе нужно объявить два дочерних класса:

**IntegerValidator** - для проверки, что _data_ - целое число в заданном диапазоне;

**FloatValidator** - для проверки, что _data_ - вещественное число в заданном диапазоне.

Объекты этих классов предполагается создавать командами:

```python
integer_validator = IntegerValidator(min_value, max_value)
float_validator = FloatValidator(min_value, max_value)
```

где _min_value_, _max_value_ - допустимый диапазон чисел _[min_value; max_value]_

Также в этих классах нужно переопределить метод:

```python
def _is_valid(self, data): ...
```

который бы возвращал _True_, если _data_ является числом верного типа (либо _int_, либо _float_ в зависимости от валидатора) и находится в заданном диапазоне _[min_value; max_value]_. 
Иначе, возвращается _False_.

Пример использования классов (эти строчки в программе писать не нужно):

```python
integer_validator = IntegerValidator(-10, 10)
float_validator = FloatValidator(-1, 1)
res1 = integer_validator(10)  # исключение не генерируется (проверка проходит)
res2 = float_validator(10)    # исключение ValueError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
 ## ex_9

### Используя механизм наследования, вам поручено разработать функционал по построению моделей нейронных сетей.

Общая схема модели очень простая:

Базовый класс _Layer_ имеет локальный атрибут _next_layer_, 
который ссылается на следующий объект слоя нейронной сети (объект класса _Layer_ или любого объекта дочерних классов).
У последнего слоя значение _next_layer = None_.

Создавать последовательность слоев предполагается командами:

```python
first_layer = Layer()
next_layer = first_layer(Layer())
next_layer = next_layer(Layer())
...
```

То есть, сначала создается объект _first_layer_ класса _Layer_, а затем он вызывается как функция для образования связки со следующим слоем.
При этом возвращается ссылка на следующий слой и переменная _next_layer_ ссылается уже на этот следующий слой нейронной сети.
И так можно создавать столько слоев, сколько необходимо.

В каждом объекте класса _Layer_ также должен формироваться локальный атрибут:

```python
name = 'Layer'
```
Но сам по себе класс _Layer_ образует только связи между слоями.
Никакой другой функциональности он не несет.
Чтобы это исправить, в программе нужно объявить еще два дочерних класса:

**Input** - формирование входного слоя нейронной сети;

**Dense** - формирование полносвязного слоя нейронной сети.

Конечно, создавать нейронную сеть мы не будем.
Поэтому, в классе _Input_ нужно лишь прописать инициализатор так, чтобы его объекты создавались следующим образом:

```python
inp = Input(inputs)
```

где _inputs_ - общее число входов (целое число).
Также в объектах класса _Input_ должен автоматически формироваться атрибут:

```python
name = 'Input'
```

(Не забывайте при этом, вызывать инициализатор базового класса _Layer_).

Объекты второго дочернего класса _Dense_ предполагается создавать командой:

```python
dense = Dense(inputs, outputs, activation)
```

где _inputs_ - число входов в слой;

_outputs_ - число выходов слоя (целые числа);

_activation_ - функция активации (строка, например: _'linear', 'relu', 'sigmoid'_).

И в каждом объекте класса _Dense_ также должен автоматически формироваться атрибут:

```python
dense = Dense(inputs, outputs, activation)
name = 'Dense'
```

Все эти классы совместно можно использовать следующим образом (эти строчки пример, писать не нужно):

```python
network = Input(128)
layer = network(Dense(network.inputs, 1024, 'linear'))
layer = layer(Dense(layer.inputs, 10, 'softmax'))
```

Здесь создается три слоя нейронной сети.

Наконец, для перебора всех слоев с помощью цикла _for_, необходимо объявить отдельный класс _NetworkIterator_ 

для итерирования (перебора) слоев нейронной сети следующим образом:

```python
for x in NetworkIterator(network):
    print(x.name)
```

Здесь создается объект класса _NetworkIterator_.

На вход передается первый объект (слой) нейронной сети.
Объект этого класса является итератором, который в цикле _for_ последовательно возвращает объекты (слои) нейронной сети.

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_10
### Объявите в программе класс _Vector_, объекты которого создаются командой:

```python
v = Vector(x1, x2, ..., xN)
```

где _x1_, _x2_, ..., _xN_ - координаты радиус-вектора (числа: целые или вещественные).

С объектами этого класса должны выполняться команды:

```python
v1 = Vector(1, 2, 3)
v2 = Vector(3, 4, 5)
v = v1 + v2 # формируется новый вектор (объект класса Vector) с соответствующими координатами
v = v1 - v2 # формируется новый вектор (объект класса Vector) с соответствующими координатами
```

Если размерности векторов _v1_ и _v2_ не совпадают, то генерировать исключение:

```python
raise TypeError('размерности векторов не совпадают')
```

В самом классе _Vector_ объявите метод с именем **get_coords**, который возвращает кортеж из текущих координат вектора.

На основе класса Vector объявите дочерний класс _VectorInt_ для работы с целочисленными координатами:

```python
v = VectorInt(1, 2, 3, 4)
v = VectorInt(1, 0.2, 3, 4) # ошибка: генерируется исключение raise ValueError('координаты должны быть целыми числами')
```

При операциях сложения и вычитания с объектом класса _VectorInt_:

```python
v = v1 + v2  # v1 - объект класса VectorInt
v = v1 - v2  # v1 - объект класса VectorInt
```

должен формироваться объект _v_ как объект класса _Vector_, если хотя бы одна координата является вещественной.

Иначе, v должен быть объектом класса _VectorInt_.

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
