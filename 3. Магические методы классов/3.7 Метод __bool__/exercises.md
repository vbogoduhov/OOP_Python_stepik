# Метод __bool__

## ex_4

## Объявите в программе класс Player (игрок), объекты которого создаются командой:

```python
player = Player(name, old, score)
```

где _name_ - имя игрока (строка); 

_old_ - возраст игрока (целое число); 

_score_ - набранные очки в игре (целое число). 

В каждом объекте класса _Player_ должны создаваться аналогичные локальные атрибуты: _name_, _old_, _score_.

С объектами класса _Player_ должна работать функция:

```python
bool(player)
```

которая возвращает _True_, если число очков больше нуля, и _False_ - в противном случае.

С помощью команды:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

считываются строки из входного потока в список строк _lst_in_. 

Каждая строка записана в формате:

_"имя; возраст; очки"_

Например:

```python
Балакирев; 34; 2048
Mediel; 27; 0
Влад; 18; 9012
Nina P; 33; 0
```

Каждую строку списка _lst_in_ необходимо представить в виде объекта класса _Player_ с соответствующими данными. 
И из этих объектов сформировать список _players_.

Отфильтруйте этот список (создайте новый: _players_filtered_), оставив всех игроков с числом очков больше нуля. 
Используйте для этого стандартную функцию _filter()_ совместно с функцией _bool()_ языка _Python_.


P.S. На экран ничего выводить не нужно.

## ex_5
### Объявите в программе класс _MailBox_ (почтовый ящик), объекты которого создаются командой:

```python
mail = MailBox()
```

Каждый объект этого класса должен содержать локальный публичный атрибут:

_inbox_list_ - список из принятых писем.

Также в классе _MailBox_ должен присутствовать метод:

```python
receive(self) - прием новых писем
```

Этот метод должен читать данные из входного потока командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

В результате формируется список _lst_in_ из строк. Каждая строка записана в формате:

```python
"от кого; заголовок; текст письма"
```

Например:

```python
sc_lib@list.ru; От Балакирева; Успехов в IT!
mail@list.ru; Выгодное предложение; Вам одобрен кредит.
mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
```

Каждая строчка списка _lst_in_ должна быть представлена объектом класса _MailItem_, объекты которого создаются командой:

```python
item = MailItem(mail_from, title, content)
```

где _mail_from_ - email отправителя (строка);

_title_ - заголовок письма (строка), 

_content_ - содержимое письма (строка). 

В каждом объекте класса _MailItem_ должны формироваться соответствующие локальные атрибуты (с именами: _mail_from_, _title_, _content_).\
И дополнительно атрибут _is_read_ (прочитано ли) с начальным значением _False_.

В классе _MailItem_ должен быть реализован метод:

**set_read(self, fl_read)** - для отметки, что письмо прочитано (метод должен устанавливать атрибут _is_read = fl_read_, если _True_, то письмо прочитано, если _False_, то не прочитано).

С каждым объектом класса _MailItem_ должна работать функция:

```python
bool(item)
```

которая возвращает _True_ для прочитанного письма и _False_ для непрочитанного.

Вызовите метод:

```python
mail.receive()
```

Отметьте первое и последнее письмо в списке _mail.inbox_list_, как прочитанное (используйте для этого метод _set_read_). 
Затем, сформируйте в программе список (глобальный) с именем _inbox_list_filtered_ из прочитанных писем, используя стандартную функцию _filter()_score_ совместно с функцией _bool()_ языка _Python_.

P.S. На экран ничего выводить не нужно.

## ex_6
### Объявите класс _Line_, объекты которого создаются командой:

```python
line = Line(x1, y1, x2, y2)
```

где _x1_, _y1_, _x2_, _y2_ - координаты начала линии _(x1, y1)_ и координаты конца линии _(x2, y2)_.

Могут быть произвольными числами. 

В объектах класса _Line_ должны создаваться соответствующие локальные атрибуты с именами _x1_, _y1_, _x2_, _y2_.

В классе _Line_ определить магический метод ___len___() так, чтобы функция:

```python
bool(line)
```

возвращала _False_, если длина линии меньше 1.

P.S. На экран ничего выводить не нужно. Только объявить класс.

## ex_7
### Объявите класс _Ellipse_ (эллипс), объекты которого создаются командами:

```python
el1 = Ellipse()  # без создания локальных атрибутов x1, y1, x2, y2
el2 = Ellipse(x1, y1, x2, y2)
```

где _x1_, _y1_ - координаты (числа) левого верхнего угла; 

_x2_, _y2_ - координаты (числа) нижнего правого угла. 

Первая команда создает объект класса _Ellipse_ без локальных атрибутов _x1_, _y1_, _x2_, _y2_. 
Вторая команда создает объект с локальными атрибутами _x1_, _y1_, _x2_, _y2_ и соответствующими переданными значениями.

В классе _Ellipse_ объявите магический метод ___bool___(), который бы возвращал _True_, если все локальные атрибуты _x1_, _y1_, _x2_, _y2_ существуют и _False_ - в противном случае.

Также в классе _Ellipse_ нужно реализовать метод:

**get_coords()** - для получения кортежа текущих координат объекта.

Если координаты отсутствуют (нет локальных атрибутов _x1_, _y1_, _x2_, _y2_), то метод **get_coords()** должен генерировать исключение командой:

```python
raise AttributeError('нет координат для извлечения')
```

Сформируйте в программе список с именем _lst_geom_, содержащий четыре объекта класса _Ellipse_. 
Два объекта должны быть созданы командой 

```python
Ellipse()
```

и еще два - командой:

```python
Ellipse(x1, y1, x2, y2)
```

Переберите список в цикле и вызовите метод **get_coords()** только для объектов, имеющих координаты _x1_, _y1_, _x2_, _y2_. 
(Помните, что для этого был определен магический метод ___bool___()).

P.S. На экран ничего выводить не нужно.
