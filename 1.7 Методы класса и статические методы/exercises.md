# Методы класса (classmethod) и статические методы (staticmethod)

## ex. 6
**В программе предполагается реализовать парсер (обработчик) строки с данными _string_ в определенный выходной формат. Для этого объявлен следующий класс:**

```python
class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq
```

И предполагается его использовать следующим образом:

```python
res = Loader.parse_format("4, 5, -6", Factory)
```
На выходе (в переменной _res_) ожидается получать список из набора целых чисел. Например, для заданной строки, должно получиться:

```python
[4, 5, -6]
```

Для реализации этой идеи необходимо вначале программы прописать класс _Factory_ с двумя статическими методами:

**build_sequence()** - для создания пустого списка (метод возвращает пустой список);

**build_number(string)** - для преобразования строки (_string_) в целое число (метод возвращает полученное целочисленное значение).

Объявите класс с именем _Factory_, чтобы получать на выходе искомый результат.

## ex. 7
**В программе объявлен следующий класс для работы с формами ввода логин/пароль:**

```python
class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
```
Который предполагается использовать следующим образом:

```python
login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
html = login.render_template()
```

Необходимо прописать классы _TextInput_ и _PasswordInput_, объекты которых формируются командами:

```python
login = TextInput(name, size)
psw = PasswordInput(name, size)
```

В каждом объекте этих классов должны быть следующие локальные свойства:

**name** - название для поля (сохраняет передаваемое имя, например, _"Логин"_ или _"Пароль"_);

**size** - размер поля ввода (целое число, по умолчанию _10_).

Также классы _TextInput_ и _PasswordInput_ должны иметь метод:

**get_html(self)** - возвращает сформированную HTML-строку в формате (1-я строка для класса _TextInput_ ; 2-я - для класса _PasswordInput_):

```python
<p class='login'><имя поля>: <input type='text' size=<размер поля> />
<p class='password'><имя поля>: <input type='text' size=<размер поля> />
```

Например, для поля _login_:

```python
<p class='login'>Логин: <input type='text' size=10 />
```

Также классы _TextInput_ и _PasswordInput_ должны иметь метод класса (_@classmethod_):

**check_name(cls, name)** - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по следующим критериям:

- длина имени не менее 3 символов и не более 50;
- в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

Если проверка не проходит, то генерировать исключение командой:

```python
raise ValueError("некорректное поле name")
```

Для проверки допустимых символов в каждом классе должен быть прописан атрибут _CHARS_CORRECT_:

```python
CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
CHARS_CORRECT = CHARS + CHARS.upper() + digits
```

По заданию нужно объявить только классы _TextInput_ и _PasswordInput_ с соответствующим функционалом. Более ничего.


## ex. 8
**Объявите класс _CardCheck_ для проверки корректности информации на пластиковых картах. Этот класс должен иметь следующие методы:**

**check_card_number(number)** - проверяет строку с номером карты и возвращает булево значение _True_, если номер в верном формате и _False_ - в противном случае. Формат номера следующий: _XXXX-XXXX-XXXX-XXXX_, где _X_ - любая цифра (от 0 до 9).

**check_name(name)** - проверяет строку name с именем пользователя карты. Возвращает булево значение _True_, если имя записано верно и _False_ - в противном случае.

Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами. Например, _SERGEI BALAKIREV_.

Предполагается использовать класс _CardCheck_ следующим образом (эти строчки в программе не писать):
```python
is_number = CardCheck.check_card_number("1234-5678-9012-0000")
is_name = CardCheck.check_name("SERGEI BALAKIREV")
```
Для проверки допустимых символов в классе должен быть прописан атрибут:
```python
CHARS_FOR_NAME = ascii_lowercase.upper() + digits
```
Подумайте, как правильнее объявить методы _check_card_number_ и _check_name_ (декораторами _@classmethod_ и _@staticmethod_).

# ex. 9
**Объявите в программе класс Video с двумя методами:**

**create(self, name)** - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте _name_ объекта класса _Video_);

**play(self)** - для воспроизведения видео (метод выводит на экран строку _"воспроизведение видео <name>"_).

Объявите еще один класс с именем _YouTube_, в котором объявите два метода (с декоратором _@classmethod_):

**add_video(cls, video)** - для добавления нового видео (метод помещает объект _video_ класса _Video_ в список);

**play(cls, video_indx)** - для проигрывания видео из списка по указанному индексу (индексация с нуля).

(здесь _cls_ - ссылка на класс _YouTube_). И список (тоже внутри класса _YouTube_):

_videos_ - для хранения добавленных объектов класса _Video_ (изначально список пуст).

Метод _play()_ класса _YouTube_ должен обращаться к объекту класса _Video_ по индексу списка _videos_ и, затем, вызывать метод _play()_ класса _Video_.

Методы _add_video_ и _play_ вызывайте напрямую из класса _YouTube_. Создавать экземпляр этого класса не нужно.

Создайте два объекта _v1_ и _v2_ класса _Video_, затем, через метод _create()_ передайте им имена _"Python"_ и _"Python ООП"_. 
После этого с помощью метода _add_video_ класса _YouTube_, добавьте в него эти два видео и воспроизведите (с помощью метода _play_ класса _YouTube_) сначала первое, а затем, второе видео.

## ex. 10
**Объявите класс _AppStore_ - интернет-магазин приложений для устройств под iOS. В этом классе должны быть реализованы следующие методы:**

**add_application(self, app)** - добавление нового приложения _app_ в магазин;

**remove_application(self, app)** - удаление приложения _app_ из магазина;

**block_application(self, app)** - блокировка приложения _app_ (устанавливает локальное свойство _blocked_ объекта _app_ в значение _True_);

**total_apps(self)** - возвращает общее число приложений в магазине.

Класс _AppStore_ предполагается использовать следующим образом (эти строчки в программе не писать):
```python
store = AppStore()
app_youtube = Application("Youtube")
store.add_application(app_youtube)
store.remove_application(app_youtube)
```

Здесь _Application_ - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса _Application_ должен содержать локальные свойства:

**name** - наименование приложения (строка);

**blocked** - булево значение (_True_ - приложение заблокировано; _False_ - не заблокировано, изначально _False_).

Как хранить список приложений в объектах класса _AppStore_ решите сами.
