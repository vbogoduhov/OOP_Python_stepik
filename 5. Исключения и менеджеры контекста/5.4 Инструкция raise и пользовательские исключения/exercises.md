# Инструкция raise и пользовательские исключения

## ex_4
### Объявите класс-исключение с именем _StringException_, унаследованным от базового класса _Exception_.

После этого объявите еще два класса-исключения:

**NegativeLengthString** - ошибка, если длина отрицательная;

**ExceedLengthString** - ошибка, если длина превышает заданное значение;

унаследованные от базового класса _StringException_.

Затем, в блоке _try_ (см. программу) пропишите команду генерации исключения для перехода в блок обработки исключения _ExceedLengthString_.

## ex_5
### Объявите в программе класс-исключение с именем _PrimaryKeyError_, унаследованным от базового класса _Exception_.

Объекты класса _PrimaryKeyError_ должны создаваться командами:

```python
e1 = PrimaryKeyError()          # Первичный ключ должен быть целым неотрицательным числом
e2 = PrimaryKeyError(id='abc')  # Значение первичного ключа id = abc недопустимо
e3 = PrimaryKeyError(pk='123')  # Значение первичного ключа pk = 123 недопустимо
```

В первом варианте команды должно формироваться сообщение об ошибке _"Первичный ключ должен быть целым неотрицательным числом"_.

При втором варианте:

```python
"Значение первичного ключа id = <id> недопустимо"
```

И при третьем:

```python
"Значение первичного ключа pk = <pk> недопустимо"
```

Эти сообщения должны формироваться при отображении объектов класса _PrimaryKeyError_, например:

```pythonprint(e2) # Значение первичного ключа id = abc недопустимо
```

Затем, сгенерируйте это исключение с аргументом _id = -10.5_, обработайте его и отобразите на экране объект исключения.

## ex_6
### Объявите класс _DateString_ для представления дат, объекты которого создаются командой:

```python
date = DateString(date_string)
```

где _date_string_ - строка с датой в формате:

```python
"DD.MM.YYYY"
```

здесь _DD_ - день (целое число от 1 до 31);

_MM_ - месяц (целое число от 1 до 12);

_YYYY_ - год (целое число от 1 до 3000).

Например:

```python
date = DateString("26.05.2022")
```

или

```python
date = DateString("26.5.2022") # незначащий ноль может отсутствовать
```

Если указанная дата в строке записана неверно (не по формату), то генерировать исключение с помощью собственного класса:

**DateError** - класс-исключения, унаследованный от класса **Exception**.

В самом классе _DateString_ переопределить магический метод **__str__()** для формирования строки даты в формате:

```python
"DD.MM.YYYY"
```

(здесь должны фигурировать незначащие нули, например, для аргумента "26.5.2022" должна формироваться строка "26.05.2022").

Далее, в программе выполняется считывание строки из входного потока командой:

```python
date_string = input()
```

Ваша задача создать объект класса _DateString_ с аргументом _date_string_ и вывести объект на экран командой:

```python
print(date) # date - объект класса DateString
```

Если же произошло исключение, то вывести сообщение (без кавычек):
```python
"Неверный формат даты"
```

## ex_7
### Вам поручается разработать класс _TupleData_, элементами которого могут являются только объекты классов: _CellInteger_, _CellFloat_ и _CellString_.


Вначале в программе нужно объявить класс _CellInteger_, _CellFloat_ и _CellString_, объекты которых создаются командами:

```python
cell_1 = CellInteger(min_value, max_value)
cell_2 = CellFloat(min_value, max_value)
cell_3 = CellString(min_length, max_length)
```

где _min_value_, _max_value_ - минимальное и максимальное допустимое значение в ячейке;

_min_length_, _max_length_ - минимальная и максимальная допустимая длина строки в ячейке.

В каждом объекте этих классов должны формироваться локальные атрибуты с именами _min_value, _max_value или _min_length, _max_length и соответствующими значениями.

Запись и считывание текущего значения в ячейке должно выполняться через объект-свойство (_property_) с именем:

**value** - для записи и считывания значения в ячейке (изначально возвращает значение _None_).

Если в момент записи новое значение не соответствует диапазону _[min_value; max_value]_ или _[min_length; max_length]_, то генерируется исключения командами:

```python
raise CellIntegerException('значение выходит за допустимый диапазон')  # для объектов класса CellInteger
raise CellFloatException('значение выходит за допустимый диапазон')    # для объектов класса CellFloat
raise CellStringException('длина строки выходит за допустимый диапазон')  # для объектов класса CellString
```

Все три класса исключений должны быть унаследованы от одного общего класса:

**CellException**

Далее, объявите класс _TupleData_, объекты которого создаются командой:

```python
ld = TupleData(cell_1, ..., cell_N)
```

где _cell_1_, ..., _cell_N_ - объекты классов _CellInteger_, _CellFloat_ и _CellString_ (в любом порядке и любом количестве).

Обращение к отдельной ячейке должно выполняться с помощью оператора:

```python
value = ld[index] # считывание значения из ячейке с индексом index
ld[index] = value # запись нового значения в ячейку с индексом index
```

Индекс _index_ отсчитывается с нуля (для первой ячейки) и является целым числом.

Если значение _index_ выходит за диапазон _[0; число ячеек-1]_, то генерировать исключение _IndexError_.

Также с объектами класса _TupleData_ должны выполняться следующие функции и операторы:

```python
res = len(ld) # возвращает общее число элементов (ячеек) в объекте ld
for d in ld:  # перебирает значения ячеек объекта ld (значения, а не объекты ячеек)
    print(d)
```

Все эти классы в программе можно использовать следующим образом:

```python
ld = TupleData(CellInteger(0, 10), CellInteger(11, 20), CellFloat(-10, 10), CellString(1, 100))

try:
    ld[0] = 1
    ld[1] = 20
    ld[2] = -5.6
    ld[3] = "Python ООП"
except CellIntegerException as e:
    print(e)
except CellFloatException as e:
    print(e)
except CellStringException as e:
    print(e)
except CellException:
    print("Ошибка при обращении к ячейке")
except Exception:
    print("Общая ошибка при работе с объектом TupleData")
```

P.S. Данная программа должна быть выполнена штатно, без ошибок. На экран отображать ничего не нужно.
