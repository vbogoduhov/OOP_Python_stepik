# Полиморфизм и абстрактные методы

## ex_3
### В программе объявлены два класса:

```python
class Student:
    def __init__(self, fio, group):
        self._fio = fio  # ФИО студента (строка)
        self._group = group # группа (строка)
        self._lect_marks = []  # оценки за лекции
        self._house_marks = []  # оценки за домашние задания

    def add_lect_marks(self, mark):
        self._lect_marks.append(mark)

    def add_house_marks(self, mark):
        self._house_marks.append(mark)

    def __str__(self):
        return f"Студент {self._fio}: оценки на лекциях: {str(self._lect_marks)}; оценки за д/з: {str(self._house_marks)}"


class Mentor:
    def __init__(self, fio, subject):
        self._fio = fio
        self._subject = subject
```

Первый класс описывает студентов, а второй - менторов.

Вам поручается на основе базового класса _Mentor_ разработать еще два дочерних класса:

**Lector** - для описания лекторов;

**Reviewer** - для описания экспертов.

Объекты этих классов должны создаваться командами:

```python
lector = Lector(fio, subject)
reviewer = Reviewer(fio, subject)
```

где _fio_ - ФИО (строка);

_subject_ - предмет (строка).

Инициализации этих параметров _(fio, subject)_ должна выполняться базовым классом _Mentor_.

В самих классах _Lector_ и _Reviewer_ необходимо объявить метод:

```python
def set_mark(self, student, mark): ...
```

для простановки оценки (_mark_) студенту (_student_).

Причем, в классе _Lector_ оценки добавляются в список **_lect_marks** объекта класса _Student_, а в классе _Reviewer_ - в список **_house_marks**.

Используйте для этого методы **add_lect_marks()** и **add_house_marks()** класса _Student_.

Также в классах _Lector_ и _Reviewer_ должен быть переопределен магический метод:

**__str__()**

для формирования следующей информации об объектах:

- для объектов класса _Lector_: ``Лектор <ФИО>: предмет <предмет>``

- для объектов класса _Reviewer_:``Эксперт <ФИО>: предмет <предмет>``


Пример использования классов (эти строчки в программе писать не нужно):

```python
lector = Lector("Балакирев С.М.", "Информатика")
reviewer = Reviewer("Гейтс Б.", "Информатика")
students = [Student("Иванов А.Б.", "ЭВМд-11"), Student("Гаврилов С.А.", "ЭВМд-11")]
persons = [lector, reviewer]
lector.set_mark(students[0], 4)
lector.set_mark(students[1], 2)
reviewer.set_mark(students[0], 5)
reviewer.set_mark(students[1], 3)
for p in persons + students:
    print(p)
# в консоли будет отображено:
# Лектор Балакирев С.М.: предмет Информатика
# Эксперт Гейтс Б.: предмет Информатика
# Студент Иванов А.Б.: оценки на лекциях: [4]; оценки за д/з: [5]
# Студент Гаврилов С.А.: оценки на лекциях: [2]; оценки за д/з: [3]
```

P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.

## ex_4
### Вам необходимо объявить базовый класс _ShopInterface_ с абстрактным методом:

```python
def get_id(self): ...
  ```

В самом методе должно генерироваться исключение командой:

```python
raise NotImplementedError('в классе не переопределен метод get_id')
```

Инициализатор в классе _ShopInterface_ прописывать не нужно.

Далее объявите дочерний класс _ShopItem_ (от базового класса _ShopInterface_), объекты которого создаются командой:

```python
item = ShopItem(name, weight, price)
```

где _name_ - название товара (строка);

_weight_ - вес товара (любое положительное число);

_price_ - цена товара (любое положительное число).

В каждом объекте класса _ShopItem_ должны формироваться локальные атрибуты с именами **_name**, **_weight**, **_price** и соответствующими значениями.

Также в объектах класса _ShopItem_ должен автоматически формироваться локальный приватный атрибут **__id** с уникальным (для каждого товара) целым значением.

В классе _ShopItem_ необходимо переопределить метод **get_id()** базового класса так, чтобы он (метод) возвращал значение атрибута **__id**.

P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.

## ex_5
### Ранее вы уже создавали классы валидации в виде иерархии базового класса _Validator_ и дочерних:

```python
StringValidator
IntegerValidator
FloatValidator
```
для валидации (проверки) корректности данных. Повторим этот функционал с некоторыми изменениями.

Итак, вначале нужно объявить базовый класс _Validator_, в котором должен отсутствовать инициализатор (магический метод **__init__**) и объявлен метод со следующей сигнатурой:

```python
def _is_valid(self, data): ...
```

По идее, этот метод возвращает булево значение _True_, если данные (_data_) корректны с точки зрения валидатора, и _False_ - в противном случае.

Но в базовом классе _Validator_ он должен генерировать исключение командой:

```python
raise NotImplementedError('в классе не переопределен метод _is_valid')
```

Затем, нужно объявить дочерний класс _FloatValidator_ для валидации вещественных чисел.

Объекты этого класса создаются командой:

```python
float_validator = FloatValidator(min_value, max_value)
```

где _min_value_ - минимально допустимое значение;

_max_value_ - максимально допустимое значение.

Пользоваться объектами класса _FloatValidator_ предполагается следующим образом:

```python
res = float_validator(value)
```

где _value_ - проверяемое значение (должно быть вещественным и находиться в диапазоне _[min_value; max_value]_).

Данный валидатор должен возвращать _True_, если значение _value_ проходит проверку, и _False_ - в противном случае.

Пример использования классов (эти строчки писать не нужно):

```python
float_validator = FloatValidator(0, 10.5)
res_1 = float_validator(1)  # False (целое число, а не вещественное)
res_2 = float_validator(1.0)  # True
res_3 = float_validator(-1.0)  # False (выход за диапазон [0; 10.5])
```

P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.

## ex_3
### В языке _Python_ есть еще один распространенный способ объявления абстрактных методов класса через декоратор _abstractmethod_ модуля _abc_:

```python
from abc import ABC, abstractmethod
```

Чтобы корректно работал декоратор _abstractmethod_ сам класс должен наследоваться от базового класса _ABC_.

Например, так:

```python
class Transport(ABC):
    @abstractmethod
    def go(self):
        """Метод для перемещения транспортного средства"""

    @classmethod
    @abstractmethod
    def abstract_class_method(cls):
        """Абстрактный метод класса"""
```

Мы здесь имеем два абстрактных метода внутри класса _Transport_, причем, первый метод **go()** - это обычный метод, а второй **abstract_class_method()** - это абстрактный метод уровня класса.

Обратите внимание на порядок использования декораторов _classmethod_ и _abstractmethod_.

Они должны быть записаны именно в такой последовательности.

Теперь, если объявить какой-либо дочерний класс, например:

```python
class Bus(Transport):
    def __init__(self, model, speed):
        self._model = model
        self._speed = speed

    def go(self):
        print("bus go")

    @classmethod
    def abstract_class_method(cls):
        pass
```

То в нем обязательно нужно переопределить абстрактные методы _go_ и _abstract_class_method_ класса _Transport_.

Иначе, объект класса _Bus_ не будет создан (возникнет исключение _TypeError_).

Используя эту информацию, объявите базовый класс _Model_ (модель), в котором нужно объявить один абстрактный метод с сигнатурой:

```python
def get_pk(self): ...
````

и один обычный метод:

```python
def get_info(self): ...
```

который бы возвращал строку 

```python
"Базовый класс Model".
```

На основе класса _Model_ объявите дочерний класс _ModelForm_, объекты которого создаются командой:

```python
form = ModelForm(login, password)
```

где _login_ - заголовок перед полем ввода логина (строка);

_password_ - заголовок перед полем ввода пароля (строка).

В каждом объекте класса _ModelForm_ должны формироваться локальные атрибуты с именами __login_ и __password_, а также автоматически появляться локальный атрибут __id_ с уникальным целочисленным значением для каждого объекта класса _ModelForm_.

В классе _ModelForm_ переопределите метод:

```python
def get_pk(self): ...
```


который должен возвращать значение атрибута __id_.

Пример использования классов (эти строчки в программе писать не нужно):

```python
form = ModelForm("Логин", "Пароль")
print(form.get_pk())
```

P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.
