# Сравнения __eq__, __ne__, __lt__, __gt__ и другие
## ex_3
### Объявите класс _Track_ (маршрут), объекты которого создаются командой:

```python
track = Track(start_x, start_y)
```

где _start_x_, _start_y_ - координаты начала маршрута (целые или вещественные числа).

Каждый линейный сегмент маршрута определяется классом _TrackLine_, объекты которого создаются командой:

```python
line = TrackLine(to_x, to_y, max_speed)
```

где _to_x_, _to_y_ - координаты следующей точки маршрута (целые или вещественные числа); 

_max_speed_ - максимальная скорость на данном участке (целое число).

Для формирования и работы с маршрутом в классе _Track_ должны быть объявлены следующие методы:

**add_track(self, tr)** - добавление линейного сегмента маршрута (следующей точки);

**get_tracks(self)** - получение кортежа из объектов класса _TrackLine_.

Также для объектов класса _Track_ должны быть реализованные следующие операции сравнения:

```python
track1 == track2  # маршруты равны, если равны их длины
track1 != track2  # маршруты не равны, если не равны их длины
track1 > track2  # True, если длина пути для track1 больше, чем для track2
track1 < track2  # True, если длина пути для track1 меньше, чем для track2
```

И функция:

```python
n = len(track) # возвращает целочисленную длину маршрута (привести к типу int) для объекта track2
```

Создайте два маршрута _track1_ и _track2_ с координатами:

```python
1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90
```

Сравните их между собой на равенство. Результат сравнения сохраните в переменной _res_eq_.

P.S. На экран в программе ничего выводить не нужно.

## ex_4
### Объявите класс _Dimensions_ (габариты) с атрибутами:

```python
MIN_DIMENSION = 10
MAX_DIMENSION = 10000
```

Каждый объект класса _Dimensions_ должен создаваться командой:

```python
d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
```

Значения _a_, _b_, _c_ должны сохраняться в локальных приватных атрибутах __a, __b, __c объектах этого класса.

Для изменения и доступа к приватным атрибутам в классе _Dimensions_ должны быть объявлены объекты-свойства (property) с именами: 

_a_, _b_, _c_. 

Причем, в момент присваивания нового значения должна выполняться проверка попадания числа в диапазон _[MIN_DIMENSION; MAX_DIMENSION]_. 
Если число не попадает, то оно игнорируется и существующее значение не меняется.

С объектами класса _Dimensions_ должны выполняться следующие операторы сравнения:

```python
dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```

Объявите в программе еще один класс с именем _ShopItem_ (товар), объекты которого создаются командой:

item = ShopItem(name, price, dim)dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```python
dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```

где 

_name_ - название товара (строка); 

_price_ - цена товара (целое или вещественное число); 

_dim_ - габариты товара (объект класса Dimensions).

В каждом объекте класса _ShopItem_ должны создаваться локальные атрибуты:

_name_ - название товара;

_price_ - цена товара;

_dim_ - габариты товара (объект класса _Dimensions_).

Создайте список с именем _lst_shop_ из четырех товаров со следующими данными:

```
- кеды; 1024; (40, 30, 120)
- зонт; 500.24; (10, 20, 50)
- холодильник; 40000; (2000, 600, 500)
- табуретка; 2000.99; (500, 200, 200)
```


Сформируйте новый список _lst_shop_sorted_ с упорядоченными по возрастанию объема (габаритов) товаров списка _lst_shop_, используя стандартную функцию _sorted()_ языка _Python_ 
и ее параметр _key_ для настройки сортировки. 
Прежний список _lst_shop_ должен оставаться без изменений.

P.S. На экран в программе ничего выводить не нужно.

## ex_5
### Имеется стихотворение, представленное следующим списком строк:

```python
stich = ["Я к вам пишу – чего же боле?",
        "Что я могу еще сказать?",
        "Теперь, я знаю, в вашей воле",
        "Меня презреньем наказать.",
        "Но вы, к моей несчастной доле",
        "Хоть каплю жалости храня,",
        "Вы не оставите меня."]
```

Необходимо в каждой строчке этого стиха убрать символы _"–?!,.;"_ в начале и в конце каждого слова и разбить строку по словам 
(слова разделяются одним или несколькими пробелами). 
На основе полученного списка слов, создать объект класса _StringText_ командой:

```python
st = StringText(lst_words)
```

где _lst_words_ - список из слов одной строчки стихотворения. 

С объектами класса _StringText_ должны быть реализованы операторы сравнения:

```python
st1 > st2   # True, если число слов в st1 больше, чем в st2
st1 >= st2  # True, если число слов в st1 больше или равно st2
st1 < st2   # True, если число слов в st1 меньше, чем в st2
st1 <= st2  # True, если число слов в st1 меньше или равно st2
```

Все объекты класса _StringText_ (для каждой строчки стихотворения) сохранить в списке _lst_text_.
Затем, сформировать новый список _lst_text_sorted_ из отсортированных объектов класса _StringText_ по убыванию числа слов.
Для сортировки использовать стандартную функцию **sorted()** языка _Python_. 
После этого преобразовать данный список (_lst_text_sorted_) в список из строк (объекты заменяются на соответствующие строки, между словами ставится пробел).

P.S. На экран в программе ничего выводить не нужно.

## ex_6
### Ваша задача написать программу поиска слова в строке.

Задача усложняется тем, что слово должно определяться в разных его формах. Например, слово:

```программирование
```

может иметь следующие формы:

```программирование, программированию, программированием, программировании, программирования, программированиям, программированиями, программированиях```


Для решения этой задачи необходимо объявить класс _Morph_ (морфология), объекты которого создаются командой:

```python
mw = Morph(word1, word2, ..., wordN)
```

где _word1, word2, ..., wordN_ - возможные формы слова.

В классе _Morph_ реализовать методы:

**add_word(self, word)** - добавление нового слова (если его нет в списке слов объекта класса _Morph_);

**get_words(self)** - получение кортежа форм слов.

Также с объектами класса _Morph_ должны выполняться следующие операторы сравнения:

```python
mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)
```

И аналогичная пара сравнений:

```python
"word" == mw1
"word" != mw1
```

После создания класса _Morph_, формируется список _dict_words_ из объектов этого класса, для следующих слов с их словоформами:

- связь, связи, связью, связей, связям, связями, связях
- формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
- вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
- эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
- день, дня, дню, днем, дне, дни, дням, днями, днях

Затем, прочитайте строку из входного потока командой:

```python
text = input()
```

Найдите все вхождения слов из списка _dict_words_ (используя операторы сравнения) в строке _text_ (без учета регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.

## ex_7
### Перед вами стоит задача выделения файлов с определенными расширениями из списка файлов, например:

```python
filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.xls"]
```

Для этого необходимо объявить класс _FileAcceptor_, объекты которого создаются командой:

```python
acceptor = FileAcceptor(ext1, ..., extN)
```

где _ext1, ..., extN_ - строки с допустимыми расширениями файлов, например: _'jpg', 'bmp', 'jpeg'_.

После этого предполагается использовать объект _acceptor_ в стандартной функции _filter_ языка _Python_ следующим образом:

```python
filenames = list(filter(acceptor, filenames))
```

То есть, объект _acceptor_ должен вызываться как функция:

```python
acceptor(filename)
```

и возвращать _True_, если файл с именем _filename_ содержит расширения, указанные при создании acceptor, и _False_ - в противном случае. 
Кроме того, с объектами класса _FileAcceptor_ должен выполняться оператор:

```python
acceptor12 = acceptor1 + acceptor2
```

Здесь формируется новый объект _acceptor12_ с уникальными расширениями первого и второго объектов. Например:

```python
acceptor1 = FileAcceptor("jpg", "jpeg", "png")
acceptor2 = FileAcceptor("png", "bmp")
acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
```

Пример использования класса (эти строчки в программе писать не нужно):

```python
acceptor_images = FileAcceptor("jpg", "jpeg", "png")
acceptor_docs = FileAcceptor("txt", "doc", "xls")
filenames = list(filter(acceptor_images + acceptor_docs, filenames))
```

P.S. На экран в программе ничего выводить не нужно.

## ex_8
### В программе необходимо объявить классы для работы с кошельками в разных валютах:

```
MoneyR - для рублевых кошельков
MoneyD - для долларовых кошельков
MoneyE - для евро-кошельков
```

Объекты этих классов могут создаваться командами:

```python
rub = MoneyR()   # с нулевым балансом
dl = MoneyD(1501.25) # с балансом в 1501.25 долларов
euro = MoneyE(100)  # с балансом в 100 евро
```

В каждом объекте этих классов должны формироваться локальные атрибуты:

**__cb** - ссылка на класс CentralBank (центральный банк, изначально _None_);

**__volume** - объем денежных средств в кошельке (если не указано, то 0).

Также в классах _MoneyR_, _MoneyD_ и _MoneyE_ должны быть объекты-свойства (_property_) для работы с локальными атрибутами:

**cb** - для изменения и считывания данных из переменной **__cb**;

**volume** - для изменения и считывания данных из переменной **__volume**.

Объекты классов должны поддерживать следующие операторы сравнения:

```python
rub < dl
dl >= euro
rub == euro  # значения сравниваются по текущему курсу центрального банка с погрешностью 0.1 (плюс-минус)
euro > rub
```

При реализации операторов сравнения считываются соответствующие значения **__volume** 
из сравниваемых объектов и приводятся к рублевому эквиваленту в соответствии с курсом валют центрального банка.

Чтобы каждый объект классов _MoneyR_, _MoneyD_ и _MoneyE_ "знал" текущие котировки, необходимо в программе объявить еще один класс _CentralBank_.
Объекты класса _CentralBank_ создаваться не должны (запретить), при выполнении команды:
```python
cb = CentralBank()
```

должно просто возвращаться значение _None_. А в самом классе должен присутствовать атрибут:

```python
rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
```

Здесь числа (в значениях словаря) - курс валюты по отношению к доллару. 

Также в _CentralBank_ должен быть метод уровня класса:

**register(cls, money)** - для регистрации объектов классов _MoneyR_, _MoneyD_ и _MoneyE_.

При регистрации значение **__cb** объекта _money_ должно ссылаться на класс _CentralBank_. 
Через эту переменную объект имеет возможность обращаться к атрибуту _rates_ класса _CentralBank_ и брать нужные котировки.

Если кошелек не зарегистрирован, то при операциях сравнения должно генерироваться исключение:

```python
raise ValueError("Неизвестен курс валют.")
```

Пример использования классов (эти строчки в программе писать не нужно):

```python
CentralBank.rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

r = MoneyR(45000)
d = MoneyD(500)

CentralBank.register(r)
CentralBank.register(d)

if r > d:
    print("неплохо")
else:
    print("нужно поднажать")
```

P.S. В программе на экран ничего выводить не нужно, только объявить классы.

## ex_9
### Необходимо объявить класс _Body_ (тело), объекты которого создаются командой:

```python
body = Body(name, ro, volume)
```

где 

_name_ - название тела (строка); 

_ro_ - плотность тела (число: вещественное или целочисленное); 

_volume_ - объем тела  (число: вещественное или целочисленное).


Для объектов класса _Body_ должны быть реализованы операторы сравнения:

```python
body1 > body2  # True, если масса тела body1 больше массы тела body2
body1 == body2 # True, если масса тела body1 равна массе тела body2
body1 < 10     # True, если масса тела body1 меньше 10
body2 == 5     # True, если масса тела body2 равна 5
```

Масса тела вычисляется по формуле:

```python
m = ro * volume
```

P.S. В программе только объявить класс, выводить на экран ничего не нужно.

## ex_10
### Объявите в программе класс с именем _Box_ (ящик), объекты которого должны создаваться командой:

```python
box = Box()
```

А сам класс иметь следующие методы:

**add_thing(self, obj)** - добавление предмета _obj_ (объект другого класса _Thing_) в ящик;

**get_things(self)** - получение списка объектов ящика.

Для описания предметов необходимо объявить еще один класс _Thing_. 
Объекты этого класса должны создаваться командой:

```python
obj = Thing(name, mass)
```

где _name_ - название предмета (строка); _mass_ - масса предмета (число: целое или вещественное).

Объекты класса _Thing_ должны поддерживать операторы сравнения:

```python
obj1 == obj2
obj1 != obj2
```

Предметы считаются равными, если у них одинаковые названия name (без учета регистра) и массы _mass_.

Также объекты класса Box должны поддерживать аналогичные операторы сравнения:

```python
box1 == box2
box1 != box2
```

Ящики считаются равными, если одинаковы их содержимое (для каждого объекта класса _Thing_ одного ящика и можно найти ровно один равный объект из второго ящика).

Пример использования классов:

```python
b1 = Box()
b2 = Box()

b1.add_thing(Thing('мел', 100))
b1.add_thing(Thing('тряпка', 200))
b1.add_thing(Thing('доска', 2000))

b2.add_thing(Thing('тряпка', 200))
b2.add_thing(Thing('мел', 100))
b2.add_thing(Thing('доска', 2000))

res = b1 == b2 # True
```

P.S. В программе только объявить классы, выводить на экран ничего не нужно.
