# Методы __eq__ и __hash__

## ex_4
### Объявите в программе класс с именем _Rect_ (прямоугольник), объекты которого создаются командой:

```python
rect = Rect(x, y, width, height)
```

где _x_, _y_ - координата верхнего левого угла (числа: целые или вещественные); _width_, _height_ - ширина и высота прямоугольника (числа: целые или вещественные).

В этом классе определите магический метод, чтобы хэши объектов класса _Rect_ с равными _width_, _height_ были равны. Например:

```python
r1 = Rect(10, 5, 100, 50)
r2 = Rect(-10, 4, 100, 50)
h1, h2 = hash(r1), hash(r2)   # h1 == h2
```


P.S. На экран ничего выводить не нужно, только объявить класс.

## ex_6
### Объявите класс с именем _ShopItem_ (товар), объекты которого создаются командой:

```python
item = ShopItem(name, weight, price)
```

где _name_ - название товара (строка); _weight_ - вес товара (число: целое или вещественное); _price_ - цена товара (число: целое или вещественное).

Определите в этом классе магические методы:

**__hash__()** - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;

**__eq__()** - чтобы объекты с одинаковыми хэшами были равны.

Затем, из входного потока прочитайте строки командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

Строки имеют следующий формат:

```python
название товара 1: вес_1 цена_1
...
название товара N: вес_N цена_N
```


Например:

```python
Системный блок: 1500 75890.56
Монитор Samsung: 2000 34000
Клавиатура: 200.44 545
Монитор Samsung: 2000 34000
```


Как видите, товары в этом списке могут совпадать.

Необходимо для всех этих строчек сформировать соответствующие объекты класса _ShopItem_ и добавить в словарь с именем _shop_items_. \
Ключами словаря должны выступать сами объекты, а значениями - список в формате:

```python
[item, total]
```

где _item_ - объект класса _ShopItem_; total_ - общее количество одинаковых объектов (с одинаковыми хэшами). 
Подумайте, как эффективно программно наполнять такой словарь, проходя по списку _lst_in_ один раз.

P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.

## ex_7
### Объявите класс с именем _DataBase_ (база данных - БД), объекты которого создаются командой:

```python
db = DataBase(path)
```

где _path_ - путь к файлу с данными БД (строка).

Также в классе _DataBase_ нужно объявить следующие методы:

**write(self, record)** - для добавления новой записи в БД, представленной объектом _record_;

**read(self, pk)** - чтение записи из БД (возвращает объект _Record_) по ее уникальному идентификатору _pk_ (уникальное целое положительное число); 

запись ищется в значениях словаря (см. ниже)

Каждая запись БД должна описываться классом _Record_, а объекты этого класса создаваться командой:

```python
record = Record(fio, descr, old)
```

где _fio_ - ФИО некоторого человека (строка); _descr_ - характеристика человека (строка); _old_ - возраст человека (целое число).

В каждом объекте класса _Record_ должны формироваться следующие локальные атрибуты:

_pk_ - уникальный идентификатор записи (число: целое, положительное); 
формируется автоматически при создании каждого нового объекта;

_fio_ - ФИО человека (строка);

_descr_ - характеристика человека (строка);

_old_ - возраст человека (целое число).

Реализовать для объектов класса _Record_ вычисление хэша по атрибутам: _fio_ и _old_ (без учета регистра). 

Если они одинаковы для разных записей, то и хэши должны получаться равными. 

Также для объектов класса _Record_ с одинаковыми хэшами оператор _==_ должен выдавать значение _True_, а с разными хэшами - _False_.

Хранить записи в БД следует в виде словаря _dict_db_ (атрибут объекта db класса _DataBase_), ключами которого являются объекты класса _Record_, а значениями список из объектов с равными хэшами:

```python
dict_db[rec1] = [rec1, rec2, ..., recN]
```

где _rec1, rec2, ..., recN_ - объекты класса Record с одинаковыми хэшами.

Для наполнения БД прочитайте строки из входного потока с помощью команды:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

где каждая строка представлена в формате:

```"ФИО; характеристика; возраст"```

Например:
```python
Балакирев С.М.; программист; 33
Кузнецов А.В.; разведчик-нелегал; 35
Суворов А.В.; полководец; 42
Иванов И.И.; фигурант всех подобных списков; 26
Балакирев С.М.; преподаватель; 37
```

Каждая строка должна быть представлена объектом класса _Record_ и записана в БД _db_ (в словарь _db.dict_db_).

P.S. На экран ничего выводить не нужно.

## ex_8
### Из входного потока необходимо прочитать список строк командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

Каждая строка содержит информацию об учебном пособии в формате:

```
"Название; автор; год издания"
```

Например:

```python
Python; Балакирев С.М.; 2020
Python ООП; Балакирев С.М.; 2021
Python ООП; Балакирев С.М.; 2022
Python; Балакирев С.М.; 2021
```


Необходимо каждую из этих строк представить объектом класса _BookStudy_, которые создаются командой:

```python
bs = BookStudy(name, author, year)
```

где _name_ - название пособия (строка); 
_author_ - автор пособия (строка); _year_ - год издания (целое число). 

Такие же публичные локальные атрибуты должны быть в объектах класса _BookStudy_.

Для каждого объекта реализовать вычисление хэша по двум атрибутам: _name_ и _author_ (без учета регистра).

Сформировать список _lst_bs_ из объектов класса _BookStudy_ на основе прочитанных строк (списка _lst_in_). \
После этого определить число книг с уникальными хэшами. Это число сохранить через переменную _unique_books_ (целое число).

P.S. На экран ничего выводить не нужно.
