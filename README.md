# Курс __Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева__

## Программа курса (те задания, которые сюда попали)

__1.3. Классы и объекты. Атрибуты классов и объектов__

- ex. 4: _Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):_
```python  
title = "Мороженое"
weight = 154
tp = "Еда"
price = 1024
```
- ex. 5: _Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:_
```Python
model = "Тойота"
color = "Розовый"
number = "П111УУ77"
```
- ex. 6: _Объявите класс с именем Notes и определите в нем следующие атрибуты:_
```Python
uid = 1005435
title = "Шутка"
author = "И.С. Бах"
pages = 2
```
- ex. 7: _Объявите класс с именем Dictionary и определите в нем следующие атрибуты:_
```Python
rus = "Питон"
eng = "Python"
```
- ex. 8: _Объявите класс с именем TravelBlog и объявите в нем атрибут:_
```Python
total_blogs = 0
```
    _Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:_
```Python
name = 'Франция'
days = 6
```
    _Увеличьте значение атрибута total_blogs класса TravelBlog на единицу._

    _Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:_
```python
name = 'Италия'
days = 5
```
    _Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу._
- ex. 9: _Объявите класс с именем Figure и двумя атрибутами:_
```python
type_fig: 'ellipse'
color: 'red'
```
    _Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:_
    ```python
    start_pt: (10, 5)
end_pt: (100, 20)
color: 'blue'
```
    _Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта fig1 в одну строчку через пробел в порядке, указанном в задании._

- ex. 10: _Объявите класс с именем Person и атрибутами:_
```python
name: 'Сергей Балакирев'
job: 'Программист'
city: 'Москва'
```
    _Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите True, если оно присутствует в объекте p1 и False - если отсутствует._

__1.4 Методы классов. Параметр _self_.__
- ex. 4: _Объявите класс с именем MediaPlayer с двумя методами:_

    __open(file)__ - для открытия медиа-файла с именем _file_ (создает локальное свойство _filename_ со значением аргумента _file_ в объекте класса _MediaPlayer_)

    __play()__ - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

    Создайте два экземпляра этого класса с именами: _media1_ и _media2_. Вызовите из них метод _open()_ с аргументом _"filemedia1"_ для объекта _media1_ и _"filemedia2"_ для объекта _media2_. После этого вызовите через объекты метод _play()_. При этом, на экране должно отобразиться две строки (без кавычек):

    ```
    "Воспроизведение filemedia1"
    "Воспроизведение filemedia2"
    ```

- ex. 5: _Объявите класс с именем Graph и методами:_

    _set_data(data)_ - передача набора данных _data_ для последующего отображения (_data_ - список числовых данных);

    _draw()_ - отображение данных (в том же порядке, что и в списке _data_)

    и атрибутом:
```
    LIMIT_Y = [0, 10]
```

    Метод _set_data()_ должен формировать локальное свойство _data_ объекта класса _Graph_. Атрибут _data_ должен ссылаться на переданный в метод список. Метод _draw()_ должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута _LIMIT_Y_ (границы включаются).

    Создайте объект _graph_1_ класса _Graph_, вызовите для него метод _set_data()_ и передайте список:
```
    [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
```
    Затем, вызовите метод _draw()_ через объект _graph_1_. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):
```
    "10 0 2 5 7"
```
- ex. 7: _Имеется следующий класс для считывания информации из входного потока:_

```python
import sys


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res
```
Которым, затем, можно воспользоваться следующим образом:
```python

sr = StreamReader()
data, result = sr.readlines()
```
Необходимо перед классом _StreamReader_ объявить еще один класс _StreamData_ с методом:
```python
def create(self, fields, lst_values): ...
```

который бы на входе получал кортеж _FIELDS_ из названий локальных атрибутов (передается в атрибут _fields_) и список строк _lst_in_ (передается в атрибут _lst_values_) и формировал бы в объекте класса _StreamData_ локальные свойства с именами полей из _fields_ и соответствующими значениями из _lst_values_.

Если создание локальных свойств проходит успешно, то метод _create()_ возвращает _True_, иначе - _False_. Если число полей и число строк не совпадает, то метод _create()_ возвращает _False_ и локальные атрибуты создавать не нужно._

P.S. В программе нужно дополнительно объявить только класс _StreamData_. Больше ничего делать не нужно.

- ex. 9: _Из входного потока читаются строки данных с помощью команды:_

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
```
в формате: _id_, _name_, _old_, _salary_ (записанные через пробел).

Например:

_1 Сергей 35 120000_

_2 Федор 23 12000_

_3 Иван 13 1200_


То есть, каждая строка - это элемент списка _lst_in_.

Необходимо в класс _DataBase_:
```Python
class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')
```
добавить два метода.

Первый метод:

_insert(self, data)_ - для добавления в конец списка _lst_data_ новых данных из переданного списка строк _data_. При этом, каждый элемент в списке _lst_data_ должен быть представлен словарем в формате:

```Python
{'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
```
Например, строка _"1 Сергей 35 120000"_ должна быть преобразована в словарь:
```Python
{'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
```
и только после этого добавляется в список _lst_data_. И так для всех строк из переданного списка _data_ в метод _insert()_.

Второй метод:

_select(self, a, b)_ - для возвращения нового списка из элементов существующего списка _lst_data_ в диапазоне индексов _[a; b]_ (включительно) (не _id_, а индексам списка). Следует иметь в виду, что граница _b_ может превышать длину списка.

**Примечание:** в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции _FIELDS_.
