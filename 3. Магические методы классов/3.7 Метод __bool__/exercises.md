# Метод __bool__

## ex_4

## Объявите в программе класс Player (игрок), объекты которого создаются командой:

```python
player = Player(name, old, score)
```

где _name_ - имя игрока (строка); 

_old_ - возраст игрока (целое число); 

_score_ - набранные очки в игре (целое число). 

В каждом объекте класса _Player_ должны создаваться аналогичные локальные атрибуты: _name_, _old_, _score_.

С объектами класса _Player_ должна работать функция:

```python
bool(player)
```

которая возвращает _True_, если число очков больше нуля, и _False_ - в противном случае.

С помощью команды:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

считываются строки из входного потока в список строк _lst_in_. 

Каждая строка записана в формате:

_"имя; возраст; очки"_

Например:

```python
Балакирев; 34; 2048
Mediel; 27; 0
Влад; 18; 9012
Nina P; 33; 0
```

Каждую строку списка _lst_in_ необходимо представить в виде объекта класса _Player_ с соответствующими данными. 
И из этих объектов сформировать список _players_.

Отфильтруйте этот список (создайте новый: _players_filtered_), оставив всех игроков с числом очков больше нуля. 
Используйте для этого стандартную функцию _filter()_ совместно с функцией _bool()_ языка _Python_.


P.S. На экран ничего выводить не нужно.

## ex_5
### Объявите в программе класс _MailBox_ (почтовый ящик), объекты которого создаются командой:

```python
mail = MailBox()
```

Каждый объект этого класса должен содержать локальный публичный атрибут:

_inbox_list_ - список из принятых писем.

Также в классе _MailBox_ должен присутствовать метод:

```python
receive(self) - прием новых писем
```

Этот метод должен читать данные из входного потока командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

В результате формируется список _lst_in_ из строк. Каждая строка записана в формате:

```python
"от кого; заголовок; текст письма"
```

Например:

```python
sc_lib@list.ru; От Балакирева; Успехов в IT!
mail@list.ru; Выгодное предложение; Вам одобрен кредит.
mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
```

Каждая строчка списка _lst_in_ должна быть представлена объектом класса _MailItem_, объекты которого создаются командой:

```python
item = MailItem(mail_from, title, content)
```

где _mail_from_ - email отправителя (строка);

_title_ - заголовок письма (строка), 

_content_ - содержимое письма (строка). 

В каждом объекте класса _MailItem_ должны формироваться соответствующие локальные атрибуты (с именами: _mail_from_, _title_, _content_).\
И дополнительно атрибут _is_read_ (прочитано ли) с начальным значением _False_.

В классе _MailItem_ должен быть реализован метод:

**set_read(self, fl_read)** - для отметки, что письмо прочитано (метод должен устанавливать атрибут _is_read = fl_read_, если _True_, то письмо прочитано, если _False_, то не прочитано).

С каждым объектом класса _MailItem_ должна работать функция:

```python
bool(item)
```

которая возвращает _True_ для прочитанного письма и _False_ для непрочитанного.

Вызовите метод:

```python
mail.receive()
```

Отметьте первое и последнее письмо в списке _mail.inbox_list_, как прочитанное (используйте для этого метод _set_read_). 
Затем, сформируйте в программе список (глобальный) с именем _inbox_list_filtered_ из прочитанных писем, используя стандартную функцию _filter()_score_ совместно с функцией _bool()_ языка _Python_.

P.S. На экран ничего выводить не нужно.

## ex_6
### Объявите класс _Line_, объекты которого создаются командой:

```python
line = Line(x1, y1, x2, y2)
```

где _x1_, _y1_, _x2_, _y2_ - координаты начала линии _(x1, y1)_ и координаты конца линии _(x2, y2)_.

Могут быть произвольными числами. 

В объектах класса _Line_ должны создаваться соответствующие локальные атрибуты с именами _x1_, _y1_, _x2_, _y2_.

В классе _Line_ определить магический метод ___len___() так, чтобы функция:

```python
bool(line)
```

возвращала _False_, если длина линии меньше 1.

P.S. На экран ничего выводить не нужно. Только объявить класс.

## ex_7
### Объявите класс _Ellipse_ (эллипс), объекты которого создаются командами:

```python
el1 = Ellipse()  # без создания локальных атрибутов x1, y1, x2, y2
el2 = Ellipse(x1, y1, x2, y2)
```

где _x1_, _y1_ - координаты (числа) левого верхнего угла; 

_x2_, _y2_ - координаты (числа) нижнего правого угла. 

Первая команда создает объект класса _Ellipse_ без локальных атрибутов _x1_, _y1_, _x2_, _y2_. 
Вторая команда создает объект с локальными атрибутами _x1_, _y1_, _x2_, _y2_ и соответствующими переданными значениями.

В классе _Ellipse_ объявите магический метод ___bool___(), который бы возвращал _True_, если все локальные атрибуты _x1_, _y1_, _x2_, _y2_ существуют и _False_ - в противном случае.

Также в классе _Ellipse_ нужно реализовать метод:

**get_coords()** - для получения кортежа текущих координат объекта.

Если координаты отсутствуют (нет локальных атрибутов _x1_, _y1_, _x2_, _y2_), то метод **get_coords()** должен генерировать исключение командой:

```python
raise AttributeError('нет координат для извлечения')
```

Сформируйте в программе список с именем _lst_geom_, содержащий четыре объекта класса _Ellipse_. 
Два объекта должны быть созданы командой 

```python
Ellipse()
```

и еще два - командой:

```python
Ellipse(x1, y1, x2, y2)
```

Переберите список в цикле и вызовите метод **get_coords()** только для объектов, имеющих координаты _x1_, _y1_, _x2_, _y2_. 
(Помните, что для этого был определен магический метод ___bool___()).

P.S. На экран ничего выводить не нужно.
## ex_8
### Вы начинаете разрабатывать игру _"Сапер"_. 
Для этого вам нужно уметь представлять и управлять игровым полем. Будем полагать, что оно имеет размеры _N x M_ клеток. 
Каждая клетка будет представлена объектом класса _Cell_ и содержать либо число мин вокруг этой клетки, либо саму мину.

Для начала в программе объявите класс _GamePole_, который будет создавать и управлять игровым полем. 
Объект этого класса должен формироваться командой:

```python
pole = GamePole(N, M, total_mines)
```

И, так как поле в игре одно, то нужно контролировать создание только одного объекта класса _GamePole_ (используйте паттерн _Singleton_, о котором мы с вами говорили, когда рассматривали магический метод ___new___()).

Объект _pole_ должен иметь локальный приватный атрибут:

___pole_cells_ - двумерный (вложенный) кортеж, размерами _N x M_ элементов (_N_ строк и _M_ столбцов), состоящий из объектов класса _Cell_.

Для доступа к этой коллекции объявите в классе _GamePole_ объект-свойство (property):

_pole_ - только для чтения (получения) ссылки на коллекцию ___pole_cells_.

Далее, в самом классе _GamePole_ объявите следующие методы:

**init_pole()** - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);

**open_cell(i, j)** - открывает ячейку с индексами _(i, j)_; нумерация индексов начинается с нуля; метод меняет значение атрибута ___is_open_ объекта _Cell_ в ячейке _(i, j)_ на _True_;

**show_pole()** - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее задание).

Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией _randint_ модуля _random_). После расстановки всех _total_mines_ мин, вычислите их количество вокруг остальных клеток (где нет мин). Область охвата - соседние (прилегающие) клетки (8 штук).

В методе _open_cell()_ необходимо проверять корректность индексов _(i, j)_. 
Если индексы указаны некорректно, то генерируется исключение командой:

```python
raise IndexError('некорректные индексы i, j клетки игрового поля')
```

Следующий класс _Cell_ описывает состояние одной ячейки игрового поля. Объекты этого класса создаются командой:

```python
cell = Cell()
```

При этом в самом объекте создаются следующие локальные приватные свойства:

___is_mine_ - булево значение _True/False_; _True_ - в клетке находится мина, _False_ - мина отсутствует;
___number_ - число мин вокруг клетки (целое число от 0 до 8);

___is_open_ - флаг того, открыта клетка или закрыта: _True_ - открыта; _False_ - закрыта.

Для работы с этими приватными атрибутами объявите в классе _Cell_ следующие объекты-свойства с именами:

**is_mine** - для записи и чтения информации из атрибута ___is_mine_;

**number** - для записи и чтения информации из атрибута ___number_;

**is_open** - для записи и чтения информации из атрибута ___is_open_.


В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение _True/False_, либо целое число от 0 до 8). Если передаваемое значение некорректно, то генерировать исключение командой:

```python
raise ValueError("недопустимое значение атрибута")
```

С объектами класса _Cell_ должна работать функция:

```python
bool(cell)
```

которая возвращает _True_, если клетка закрыта и _False_ - если открыта.

Пример использования классов (эти строчки в программе писать не нужно):

```python
pole = GamePole(10, 20, 10)  # создается поле размерами 10x20 с общим числом мин 10
pole.init_pole()
if pole.pole[0][1]:
    pole.open_cell(0, 1)
if pole.pole[3][5]:
    pole.open_cell(3, 5)
pole.open_cell(30, 100)  # генерируется исключение IndexError
pole.show_pole()
```

P.S. В программе на экран выводить ничего не нужно, только объявить классы.

## ex_9
### Объявите в программе класс _Vector_, объекты которого создаются командой:

```python
v = Vector(x1, x2, x3,..., xN)
```

где _x1_, _x2_, _x3_,..., _xN_ - координаты вектора (числа: целые или вещественные).

С каждым объектом класса _Vector_ должны выполняться операторы:

```python
v1 + v2 # суммирование соответствующих координат векторов
v1 - v2 # вычитание соответствующих координат векторов
v1 * v2 # умножение соответствующих координат векторов

v1 += 10 # прибавление ко всем координатам вектора числа 10
v1 -= 10 # вычитание из всех координат вектора числа 10
v1 += v2
v2 -= v1

v1 == v2 # True, если соответствующие координаты векторов равны
v1 != v2 # True, если хотя бы одна пара координат векторов не совпадает
```

При реализации бинарных операторов +, -, * следует создавать новые объекты класса _Vector_ с новыми (вычисленными) координатами. 
При реализации операторов +=, -= координаты меняются в текущем объекте, не создавая новый.

Если число координат (размерность) векторов _v1_ и _v2_ не совпадает, то при операторах +, -, * должно генерироваться исключение командой:

```python
raise ArithmeticError('размерности векторов не совпадают')
```

P.S. В программе на экран выводить ничего не нужно, только объявить класс.
