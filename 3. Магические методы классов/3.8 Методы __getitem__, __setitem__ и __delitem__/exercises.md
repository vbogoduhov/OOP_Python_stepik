# Методы __getitem__, __setitem__ и __delitem__

## ex_2
 ### Объявите класс _Record_ (запись), который описывает одну произвольную запись из БД. 

 Объекты этого класса создаются командой:

```Python
r = Record(field_name1=value1,... , field_nameN=valueN)
```

где _field_nameX_ - наименование поля БД; _valueX_ - значение поля из БД.

В каждом объекте класса _Record_ должны автоматически создаваться локальные публичные атрибуты 
по именам полей _(field_name1,... , field_nameN)_ с соответствующими значениями. 
Например:

```Python
r = Record(pk=1, title='Python ООП', author='Балакирев')
```

В объекте r появляются атрибуты:

```python
r.pk # 1
r.title # Python ООП
r.author # Балакирев
```

Также необходимо обеспечить доступ к этим полям (чтение/запись) через индексы следующим образом:

```python
r[0] = 2 # доступ к полю pk
r[1] = 'Супер курс по ООП' # доступ к полю title
r[2] = 'Балакирев С.М.' # доступ к полю author
print(r[1]) # Супер курс по ООП
r[3] # генерируется исключение IndexError
```

Если указывается неверный индекс (не целое число или некорректное целое число), то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс поля')
```

P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.

P.P.S. Для создания локальных атрибутов используйте коллекцию ___dict___ объекта класса _Record_.


## ex_3
### Вам необходимо для навигатора реализовать определение маршрутов. 
Для этого в программе нужно объявить класс _Track_, объекты которого создаются командой:

```python
tr = Track(start_x, start_y)
```

где _start_x_, _start_y_ - координата начала пути.

В этом классе должен быть реализован следующий метод:

**add_point(x, y, speed)** - добавление новой точки маршрута (линейный сегмент), 
который можно пройти со средней скоростью _speed_.

Также с объектами класса _Track_ должны выполняться команды:

```python
coord, speed = tr[indx] # получение координаты (кортеж с двумя числами) и скорости (число) для линейного сегмента маршрута с индексом indx
tr[indx] = speed # изменение средней скорости линейного участка маршрута по индексу indx
```

Если индекс _(indx)_ указан некорректно (должен быть целым числом от 0 до N-1, 
где _N_ - число линейных сегментов в маршруте), то генерируется исключение командой:

```python
raise IndexError('некорректный индекс')
```

Пример использования класса (эти строчки в программе не писать):

```python
tr = Track(10, -5.4)
tr.add_point(20, 0, 100) # первый линейный сегмент: indx = 0
tr.add_point(50, -20, 80) # второй линейный сегмент: indx = 1
tr.add_point(63.45, 1.24, 60.34) # третий линейный сегмент: indx = 2

tr[2] = 60
c, s = tr[2]
print(c, s)

res = tr[3] # IndexError
```

P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.

## ex_4
### Вам необходимо написать программу по работе с массивом однотипных данных (например, только числа или строки и т.п.). 
Для этого нужно объявить класс с именем _Array_, объекты которого создаются командой:

```python
ar = Array(max_length, cell)
```

где _max_length_ - максимальное количество элементов в массиве; 
_cell_ - ссылка на класс, описывающий отдельный элемент этого массива (см. далее, класс _Integer_). 
Начальные значения в ячейках массива (в объектах класса _Integer_) должны быть равны 0.

Для работы с целыми числами объявите в программе еще один класс с именем _Integer_, объекты которого создаются командой:

```python
cell = Integer(start_value)
```

где _start_value_ - начальное значение ячейки (в данном случае - целое число).

В классе _Integer_ должно быть следующее свойство (_property_):

**value** - для изменения и считывания значения из ячейки 
(само значение хранится в локальной приватной переменной; имя придумайте сами).

При попытке присвоить не целое число должно генерироваться исключение командой:

```python
raise ValueError('должно быть целое число')
```

Для обращения к отдельным элементам массива в классе _Array_
необходимо определить набор магических методов для следующих операций:

```python
value = ar[0] # получение значения из первого элемента (ячейки) массива ar
ar[1] = value # запись нового значения во вторую ячейку массива ar
```

Если индекс не целое число или число меньше нуля или больше либо равно _max_length_, 
то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс для доступа к элементам массива')
```

Пример использования классов (эти строчки в программе не писать):

```python
ar_int = Array(10, cell=Integer)
print(ar_int[3])
print(ar_int) # должны отображаться все значения массива в одну строчку через пробел
ar_int[1] = 10
ar_int[1] = 10.5 # должно генерироваться исключение ValueError
ar_int[10] = 1 # должно генерироваться исключение IndexError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

P.P.S. В качестве дополнительного домашнего задания: 
объявите еще один класс _Float_ для работы с вещественными числами и создайте массив, используя тот же класс _Array_, с этим новым типом данных.

## ex_5
### Вам необходимо написать программу для удобного обращения с таблицами однотипных данных (чисел, строк, булевых значений и т.п.), то есть, все ячейки таблицы должны представлять какой-то один указанный тип.

Для этого в программе необходимо объявить три класса:

**TableValues** - для работы с таблицей в целом;

**CellInteger** - для операций с целыми числами;

**IntegerValue** - дескриптор данных для работы с целыми числами.

Начнем с дескриптора _IntegerValue_. 

Это должен быть дескриптор данных (то есть, и для записи и считывания значений). 
Если присваиваемое значение не является целым числом, должно генерироваться исключение командой:

```python
raise ValueError('возможны только целочисленные значения')
```

Следующий класс _CellInteger_ описывает одну ячейку таблицы для работы с целыми числами.

В этом классе должен быть публичный атрибут (атрибут класса):

**value** - объект дескриптора, класса _IntegerValue_.

А объекты класса _CellInteger_ должны создаваться командой:

```python
cell = CellInteger(start_value)
```

где _start_value_ - начальное значение ячейки (по умолчанию равно 0 и сохраняется в ячейке через дескриптор _value_).

Наконец, объекты последнего класса _TableValues_ создаются командой:

```python
table = TableValues(rows, cols, cell=CellInteger)
```

где _rows, cols_ - число строк и столбцов (целые числа); 
_cell_ - ссылка на класс, описывающий работу с отдельными ячейками таблицы. 
Если параметр _cell_ не указан, то генерировать исключение командой:

```python
raise ValueError('параметр cell не указан')
```

Иначе, в объекте table класса _TableValues_ создается двумерный (вложенный) кортеж с именем _cells_ размером _rows x cols_, 
состоящий из объектов указанного класса (в данном примере - класса _CellInteger_).

Также в классе _TableValues_ предусмотреть возможность обращения к отдельной ячейке по ее индексам, например:

```python
value = table[1, 2] # возвращает значение ячейки с индексом (1, 2)
table[0, 0] = value # записывает новое значение в ячейку (0, 0)
```

Обратите внимание, по индексам сразу должно возвращаться значение ячейки, а не объект класса _CellInteger_. 

И то же самое с присваиванием нового значения.

Пример использования классов (эти строчки в программе не писать):

```python
table = TableValues(2, 3, cell=CellInteger)
print(table[0, 1])
table[1, 1] = 10
table[0, 0] = 1.45 # генерируется исключение ValueError

# вывод таблицы в консоль
for row in table.cells:
    for x in row:
        print(x.value, end=' ')
    print()
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

P.P.S. В качестве домашнего задания создайте класс _CellString_ для работы со строками и используйте тот же класс _TableValues_ для этого нового типа данных.

Последнее: дескрипторы здесь для повторения. В реальной разработке лучше использовать в таких задачах объекты-свойства (_property_).

## ex_6
### Ранее вы уже создавали стек-подобную структуру, когда один объект ссылается на следующий и так по цепочке до последнего:

Для этого в программе объявлялись два класса: 

**StackObj** - для описания объектов стека;

**Stack** - для управления стек-подобной структурой.

И, далее, объекты класса _StackObj_ следовало создавать командой:

```python
obj = StackObj(data)
```

где _data_ - это строка с некоторым содержимым объекта (данными).

При этом каждый объект класса _StackObj_ должен иметь следующие локальные атрибуты:

_data_ - ссылка на строку с данными, указанными при создании объекта;

_next_ - ссылка на следующий объект класса _StackObj_ (при создании объекта принимает значение _None_).

Класс _Stack_ предполагается использовать следующим образом:

```python
st = Stack() # создание объекта стек-подобной структуры
```

В каждом объекте класса _Stack_ должен быть локальный публичный атрибут:

_top_ - ссылка на первый объект стека (если стек пуст, то _top = None_).

А в самом классе _Stack_ следующие методы:

**push(self, obj)** - добавление объекта класса _StackObj_ в конец стека;

**pop(self)** - извлечение последнего объекта с его удалением из стека;

Дополнительно в классе _Stack_ нужно объявить магические методы для обращения к объекту стека по его индексу, например:

```python
obj_top = st[0] # получение первого объекта
obj = st[4] # получение 5-го объекта стека
st[2] = StackObj("obj3") # замена прежнего (3-го) объекта стека на новый
```

Если индекс не целое число или число меньше нуля или больше числа объектов в стеке, то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс')
```

Пример использования классов _Stack_ и _StackObj_ (эти строчки в программе не писать):

```python
st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st[1] = StackObj("new obj2")
print(st[2].data) # obj3
print(st[1].data) # new obj2
res = st[3] # исключение IndexError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_7

### Объявите в программе класс с именем _RadiusVector_ (радиус-вектор), объекты которого создаются командой:

```python
v = RadiusVector(x1, x2,..., xN)
```

где _x1, x2,..., xN_ - координаты радиус-вектора (числа: целые или вещественные).

В каждом объекте класса _RadiusVector_ должен быть локальный атрибут:

_coords_ - список из координат радиус-вектора.

Для доступа к отдельным координатам, реализовать следующий функционал:

```python
coord = v[i] # получение значения i-й координаты (целое число, отсчет с нуля)
coords_1 = v[start:stop] # получение среза (набора) координат в виде кортежа
coords_2 = v[start:stop:step] # получение среза (набора) координат в виде кортежа
v[i] = value # изменение i-й координаты
v[start:stop] = [val_1, val_2, ...] # изменение сразу нескольких координат
v[start:stop:step] = [val_1, val_2, ...] # изменение сразу нескольких координат
```

Пример использования класса (эти строчки в программе не писать):

```python
v = RadiusVector(1, 1, 1, 1)
print(v[1]) # 1
v[:] = 1, 2, 3, 4
print(v[2]) # 3
print(v[1:]) # (2, 3, 4)
v[0] = 10.5
```

P.S. При передаче среза в магических методах ___setitem__()_ и ___getitem__()_ параметр индекса становится объектом класса _slice_. 
Его можно указывать непосредственно в квадратных скобках упорядоченных коллекций (списков, кортежей и т.п.).

## ex_8
### Вам нужно реализовать в программе игровое поле для игры "Крестики-нолики". 

Для этого требуется объявить класс _TicTacToe_ (крестики-нолики), объекты которого создаются командой:

```python
game = TicTacToe()
```

Каждый объект game должен иметь публичный атрибут:

_pole_ - игровое поле: кортеж размером 3х3 с объектами класса _Cell_.

Каждая клетка игрового поля представляется объектом класса _Cell_ и создается командой:

```python
cell = Cell()
```

Объекты класса _Cell_ должны иметь следующие публичные локальные атрибуты:

_is_free_ - _True_, если клетка свободна; _False_ в противном случае;

_value_ - значение поля: **1** - крестик; **2** - нолик (по умолчанию **0**).

Также с каждым объектом класса _Cell_ должна работать функция:

```python
bool(cell)
```

которая возвращает _True_, если клетка свободна _(cell.is_free=True)_ и _False_ в противном случае.

Класс _TicTacToe_ должен иметь следующий метод:

**clear()** - очистка игрового поля (все клетки заполняются нулями и переводятся в закрытое состояние);

А объекты этого класса должны иметь следующую функциональность (обращение по индексам):

```python
game[0, 0] = 1 # установка нового значения, если поле закрыто
res = game[1, 1] # получение значения центральной ячейки поля (возвращается число)
```

Если указываются некорректные индексы, то должно генерироваться исключение командой:

```python
raise IndexError('неверный индекс клетки')
```

Если идет попытка присвоить новое значение в открытую клетку поля, то генерировать исключение:

```python
raise ValueError('клетка уже занята')
```

Также должны быть реализованы следующие полные срезы при обращении к клеткам игрового поля:

```python
slice_1 = game[:, indx] # выбираются все элементы (кортеж) столбца с индексом indx
slice_2 = game[indx, :] # выбираются все элементы (кортеж) строки с индексом indx
```

Пример использования классов (эти строчки в программе не писать):

```python
game = TicTacToe()
game.clear()
game[0, 0] = 1
game[1, 0] = 2
# формируется поле:
# 1 0 0
# 2 0 0
# 0 0 0
game[3, 2] = 2 # генерируется исключение IndexError
if game[0, 0] == 0:
    game[0, 0] = 2
v1 = game[0, :]  # 1, 0, 0
v2 = game[:, 0]  # 1, 2, 0
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_9
### Объявите в программе класс _Bag_ (сумка), объекты которого создаются командой:

```python
bag = Bag(max_weight)
```

где _max_weight_ - максимальный суммарный вес предметов, который можно положить в сумку.

Каждый предмет описывается классом _Thing_ и создается командой:

```python
t = Thing(name, weight)
```

где _name_ - название предмета (строка); _weight_ - вес предмета (вещественное или целочисленное значение). 
В объектах класса _Thing_ должны автоматически формироваться локальные свойства с теми же именами: _name_ и _weight_.

В классе _Bag_ должен быть реализован метод:

**add_thing(thing)** - добавление нового объекта _thing_ класса _Thing_ в сумку.

Добавление выполняется только если суммарный вес вещей не превышает параметра _max_weight_. 

Иначе, генерируется исключение:

```python
raise ValueError('превышен суммарный вес предметов')
```

Также с объектами класса _Bag_ должны выполняться следующие команды:

```python
t = bag[indx] # получение объекта класса Thing по индексу indx (в порядке добавления вещей, начиная с 0)
bag[indx] = t # замена прежней вещи на новую t, расположенной по индексу indx
del bag[indx] # удаление вещи из сумки, расположенной по индексу indx
```

Если индекс в этих командах указывается неверно, то должно генерироваться исключение:

```python
raise IndexError('неверный индекс')
```

Пример использования классов (эти строчки в программе не писать):

```python
bag = Bag(1000)
bag.add_thing(Thing('книга', 100))
bag.add_thing(Thing('носки', 200))
bag.add_thing(Thing('рубашка', 500))
bag.add_thing(Thing('ножницы', 300)) # генерируется исключение ValueError
print(bag[2].name) # рубашка
bag[1] = Thing('платок', 100)
print(bag[1].name) # платок
del bag[0]
print(bag[0].name) # платок
t = bag[4] # генерируется исключение IndexError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
