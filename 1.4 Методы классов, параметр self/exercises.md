__1.4 Методы классов. Параметр _self_.__
- ex. 4: _Объявите класс с именем MediaPlayer с двумя методами:_

    _open(file)_ - для открытия медиа-файла с именем _file_ (создает локальное свойство _filename_ со значением аргумента _file_ в объекте класса _MediaPlayer_)

    _play()_ - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

Создайте два экземпляра этого класса с именами: _media1_ и _media2_. Вызовите из них метод _open()_ с аргументом _"filemedia1"_ для объекта _media1_ и _"filemedia2"_ для объекта _media2_. После этого вызовите через объекты метод _play()_. При этом, на экране должно отобразиться две строки (без кавычек):

```python
"Воспроизведение filemedia1"
"Воспроизведение filemedia2"
```

- ex. 5: _Объявите класс с именем Graph и методами:_

    _set_data(data)_ - передача набора данных _data_ для последующего отображения (_data_ - список числовых данных);

    _draw()_ - отображение данных (в том же порядке, что и в списке _data_)

    и атрибутом:
```python
    LIMIT_Y = [0, 10]
```

Метод _set_data()_ должен формировать локальное свойство _data_ объекта класса _Graph_. Атрибут _data_ должен ссылаться на переданный в метод список. Метод _draw()_ должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута _LIMIT_Y_ (границы включаются).

Создайте объект _graph_1_ класса _Graph_, вызовите для него метод _set_data()_ и передайте список:
```python
    [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
```
Затем, вызовите метод _draw()_ через объект _graph_1_. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):
```python
"10 0 2 5 7"
```
- ex. 7: _Имеется следующий класс для считывания информации из входного потока:_

```python
import sys


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res
```
Которым, затем, можно воспользоваться следующим образом:
```python

sr = StreamReader()
data, result = sr.readlines()
```
Необходимо перед классом _StreamReader_ объявить еще один класс _StreamData_ с методом:
```python
def create(self, fields, lst_values): ...
```

который бы на входе получал кортеж _FIELDS_ из названий локальных атрибутов (передается в атрибут _fields_) и список строк _lst_in_ (передается в атрибут _lst_values_) и формировал бы в объекте класса _StreamData_ локальные свойства с именами полей из _fields_ и соответствующими значениями из _lst_values_.

Если создание локальных свойств проходит успешно, то метод _create()_ возвращает _True_, иначе - _False_. Если число полей и число строк не совпадает, то метод _create()_ возвращает _False_ и локальные атрибуты создавать не нужно.

P.S. В программе нужно дополнительно объявить только класс _StreamData_. Больше ничего делать не нужно.

- ex. 9: _Из входного потока читаются строки данных с помощью команды:_

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
```
в формате: _id_, _name_, _old_, _salary_ (записанные через пробел).

Например:

_1 Сергей 35 120000_

_2 Федор 23 12000_

_3 Иван 13 1200_


То есть, каждая строка - это элемент списка _lst_in_.

Необходимо в класс _DataBase_:
```Python
class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')
```
добавить два метода.

Первый метод:

_insert(self, data)_ - для добавления в конец списка _lst_data_ новых данных из переданного списка строк _data_. При этом, каждый элемент в списке _lst_data_ должен быть представлен словарем в формате:

```Python
{'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
```
Например, строка _"1 Сергей 35 120000"_ должна быть преобразована в словарь:
```Python
{'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
```
и только после этого добавляется в список _lst_data_. И так для всех строк из переданного списка _data_ в метод _insert()_.

Второй метод:

_select(self, a, b)_ - для возвращения нового списка из элементов существующего списка _lst_data_ в диапазоне индексов _[a; b]_ (включительно) (не _id_, а индексам списка). Следует иметь в виду, что граница _b_ может превышать длину списка.

**Примечание:** в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции _FIELDS_.

- ex. 10: _Дан класс Translator (для перевода с английского на русский), в котором объявлены три метода:_

```python
class Translator:
    def add(self, eng, rus):
        if 'tr' not in self.__dict__:
            self.tr = {}

        self.tr.setdefault(eng, [])
        # здесь продолжайте метод add

    def remove(self, eng):
        # здесь продолжайте метод remove

    def translate(self, eng):
        # здесь продолжайте метод translate
```

  В объекте этого класса должны локально (в атрибуте _tr_) храниться связки между английским и русскими словами в виде следующего словаря:

  **{'<английское слово>': [<одно или несколько русских слов>], ...}**

  Методы должны делать следующее:

  __add(self, eng, rus)__ - для добавления в словарь новой связки английского и русского слова (если английское слово уже существует, то новое русское слово добавляется как синоним для перевода, например, _go_ - идти, ходить, ехать); если связка _eng-rus_ уже существует, то второй раз ее добавлять не нужно, например:  _add('go', 'идти'), add('go', 'идти')_;

  __remove(self, eng)__ - для удаления из словаря связки по указанному английскому слову;

  __translate(self, eng)__ - для перевода с английского на русский (метод должен возвращать список из русских слов, соответствующих переводу английского слова, даже если в списке всего одно слово).

  Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса _Translator_, т.е. связки хранить локально внутри экземпляров классов класса _Translator_, используя коллекцию-словарь. (Хранить связки непосредственно в коллекции **\_\_dict\_\_** не нужно!)

  Создайте экземпляр _tr_ класса _Translator_ и вызовите метод add для следующих связок:

  ```
  tree - дерево
  car - машина
  car - автомобиль
  leaf - лист
  river - река
  go - идти
  go - ехать
  go - ходить
  milk - молоко
```

  Затем методом _remove()_ удалите связку для английского слова _car_. С помощью метода _translate()_ переведите слово _go_. Результат выведите на экран в виде строки из всех русских слов, связанных со словом _go_:
