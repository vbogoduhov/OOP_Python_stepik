# Методы __setattr__, __getattribute__, __getattr__ и __delattr__

## ex. 3
### Объявите класс Book для представления информации о книге. 
Объекты этого класса должны создаваться командами:

```python
book = Book()
book = Book(название, автор, число страниц, год издания)
```

В каждом объекте класса _Book_ автоматически должны формироваться следующие локальные свойства:

**title** - заголовок книги (строка, по умолчанию пустая строка);

**author** - автор книги (строка, по умолчанию пустая строка);

**pages** - число страниц (целое число, по умолчанию 0);

**year** - год издания (целое число, по умолчанию 0).

Объявите в классе _Book_ магический метод ___setattr___ для проверки типов присваиваемых данных локальным свойствам _title_, _author_, _pages_ и _year_.
Если типы не соответствуют локальному атрибуту (например, _title_ должна ссылаться на строку, а _pages_ - на целое число), то генерировать исключение командой:

```python
raise TypeError("Неверный тип присваиваемых данных.")
```

Создайте в программе объект _book_ класса _Book_ для книги:

```python
автор: Сергей Балакирев
заголовок: Python ООП
pages: 123
year: 2022
```

## ex. 4
### Вы создаете интернет-магазин. 
Для этого нужно объявить два класса:

**Shop** - класс для управления магазином в целом;

**Product** - класс для представления отдельного товара.

Объекты класса _Shop_ следует создавать командой:

```python
shop = Shop(название магазина)
```

В каждом объекте класса _Shop_ должно создаваться локальное свойство:

_goods_ - список товаров (изначально список пустой).

А также в классе объявить методы:

**add_product(self, product)** - добавление нового товара в магазин (в конец списка _goods_);

**remove_product(self, product)** - удаление товара product из магазина (из списка _goods_);

Объекты класса _Product_ следует создавать командой:
```python
p = Product(название, вес, цена)
```

В них автоматически должны формироваться локальные атрибуты:

_id_ - уникальный идентификационный номер товара (генерируется автоматически как целое положительное число от 1 и далее);

_name_ - название товара (строка);

_weight_ - вес товара (целое или вещественное положительное число);

_price_ - цена (целое или вещественное положительное число).

В классе _Product_ через магические методы (подумайте какие) осуществить проверку на тип присваиваемых данных локальным атрибутам объектов класса (например, _id_ - целое число, _name- - строка и т.п.).
Если проверка не проходит, то генерировать исключение командой:
```python
raise TypeError("Неверный тип присваиваемых данных.")
```

Также в классе _Product_ с помощью магического(их) метода(ов) запретить удаление локального атрибута _id_.
При попытке это сделать генерировать исключение:
```python
raise AttributeError("Атрибут id удалять запрещено.")
```

Пример использования классов (в программе эти строчки не писать):

```python
shop = Shop("Балакирев и К")
book = Product("Python ООП", 100, 1024)
shop.add_product(book)
shop.add_product(Product("Python", 150, 512))
for p in shop.goods:
    print(f"{p.name}, {p.weight}, {p.price}")
```

## ex. 5
### Необходимо создать программу для обучающего курса. 
Для этого объявляются три класса:

**Course** - класс, отвечающий за управление курсом в целом;

**Module** - класс, описывающий один модуль (раздел) курса;

**LessonItem** - класс одного занятия (урока).


Объекты класса _LessonItem_ должны создаваться командой:
```python
lesson = LessonItem(название урока, число практических занятий, общая длительность урока)
```

Соответственно, в каждом объекте класса _LessonItem_ должны создаваться локальные атрибуты:

_title_ - название урока (строка);

_practices_ - число практических занятий (целое положительное число);

_duration_ - общая длительность урока (целое положительное число).

Необходимо с помощью магических методов реализовать следующую логику взаимодействия с объектами класса _LessonItem_:

1. Проверять тип присваиваемых данных локальным атрибутам. 
Если типы не соответствуют требованиям, то генерировать исключение командой:
    ```python
    raise TypeError("Неверный тип присваиваемых данных.")
    ```
2. При обращении к несуществующим атрибутам объектов класса _LessonItem_ возвращать значение _False_.
3. Запретить удаление атрибутов _title_, _practices_ и _duration_ в объектах класса _LessonItem_.

Объекты класса _Module_ должны создаваться командой:
```python
module = Module(название модуля)
```
Каждый объект класса _Module_ должен содержать локальные атрибуты:

_name_ - название модуля;

_lessons_ - список из уроков (объектов класса _LessonItem_), входящих в модуль (изначально список пуст).

Также в классе _Module_ должны быть реализованы методы:

**add_lesson(self, lesson)** - добавление в модуль (в конец списка _lessons_) нового урока (объекта класса _LessonItem_);

**remove_lesson(self, indx)** - удаление урока по индексу в списке _lessons_.

Наконец, объекты класса _Course_ создаются командой:
```python
course = Course(название курса)
```

И содержат следующие локальные атрибуты:

_name_ - название курса (строка);

_modules_ - список модулей в курсе (изначально список пуст).

Также в классе Course должны присутствовать следующие методы:

**add_module(self, module)** - добавление нового модуля в конце списка _modules_;

**remove_module(self, indx)** - удаление модуля из списка _modules_ по индексу в этом списке.

Пример использования классов (в программе эти строчки не писать):

```python
course = Course("Python ООП")
module_1 = Module("Часть первая")
module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
module_1.add_lesson(LessonItem("Урок 3", 5, 800))
course.add_module(module_1)
module_2 = Module("Часть вторая")
module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
course.add_module(module_2)
```

## ex. 6
### Вам необходимо написать программу описания музеев. 
Для этого нужно объявить класс _Museum_, объекты которого формируются командой:
```python
mus = Museum(название музея)
```
В объектах этого класса должны формироваться следующие локальные атрибуты:

_name_ - название музея (строка);

_exhibits_ - список экспонатов (изначально пустой список).

Сам класс _Museum_ должен иметь методы:

**add_exhibit(self, obj)** - добавление нового экспоната в музей (в конец списка _exhibits_);

**remove_exhibit(self, obj)** - удаление экспоната из музея (из списка _exhibits_ по ссылке _obj_ - на экспонат)

**get_info_exhibit(self, indx)** - получение информации об экспонате (строка) по индексу списка (нумерация с нуля).

Экспонаты представляются объектами своих классов. Для примера объявите в программе следующие классы экспонатов:

_Picture_ - для картин;

_Mummies_ - для мумий;

_Papyri_ - для папирусов.

Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):

```python
p = Picture(название, художник, описание)            # локальные атрибуты: name - название; author - художник; descr - описание
m = Mummies(имя мумии, место находки, описание)      # локальные атрибуты: name - имя мумии; location - место находки; descr - описание
pr = Papyri(название папируса, датировка, описание)  # локальные атрибуты: name - название папируса; date - датировка (строка); descr - описание
```
Метод _get_info_exhibit()_ класса Museum должен возвращать значение атрибута _descr_ указанного экспоната в формате:
```python
"Описание экспоната {name}: {descr}"
```

Например:

```"Описание экспоната Девятый вал: Айвазовский написал супер картину."```

Пример использования классов (в программе эти строчки писать не нужно - только для примера):

```python
mus = Museum("Эрмитаж")
mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор", "Вдохновляющая, устрашающая, волнующая картина"))
mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))
p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство о языках программирования")
mus.add_exhibit(p)
for x in mus.exhibits:
    print(x.descr)
```