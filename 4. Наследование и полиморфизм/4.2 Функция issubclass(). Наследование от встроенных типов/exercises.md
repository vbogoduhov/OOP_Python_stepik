# Функция _issubclass()_. Наследование от встроенных типов

## ex_3

### Создается проект, в котором предполагается использовать списки из целых чисел.

Для этого вам ставится задача создать класс с именем _ListInteger_ с базовым классом _list_ и переопределить три метода:

**__init__()**

**__setitem__()**

**append()**

так, чтобы список _ListInteger_ содержал только целые числа.

При попытке присвоить любой другой тип данных, генерировать исключение командой:

```pyth

raise TypeError('можно передавать только целочисленные значения')
```

Пример использования класса _ListInteger_ (эти строчки в программе не писать):

```pyth
s = ListInteger((1, 2, 3))
s[1] = 10
s.append(11)
print(s)
s[0] = 10.5 # TypeError
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_4
### Разрабатывается интернет-магазин.

Каждый товар предполагается представлять классом _Thing_, объекты которого создаются командой:

```pyth
thing = Thing(name, price, weight)
```

где _name_ - наименование товара (строка);

_price_ - цена (вещественное число);

_weight_ - вес товара (вещественное число).

В каждом объекте этого класса создаются аналогичные атрибуты: _name_, _price_, _weight_.

Класс _Thing_ необходимо определить так, чтобы его объекты можно было использовать в качестве ключей словаря, например:

```pyth
d = {}
d[thing] = thing
```

И для каждого уникального набора данных _name_, _price_, _weight_ должны формироваться свои уникальные ключи.

Затем, вам необходимо объявить класс словаря _DictShop_, унаследованный от базового класса _dict_.

В этом новом словаре ключами могут выступать только объекты класса _Thing_.

При попытке указать любой другой тип, генерировать исключение командой:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Объекты класса _DictShop_ должны создаваться командами:

```python
dict_things = DictShop() # пустой словарь
dict_things = DictShop(things) # словарь с набором словаря things
```

где _things_ - некоторый словарь.

В инициализаторе следует проверять, чтобы аргумент _thing_ был словарем, если не так, то выбрасывать исключение:

```python
raise TypeError('аргумент должен быть словарем')
```

И проверять, чтобы все ключи являлись объектами класса _Thing_.

Если это не так, то генерировать исключение:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Дополнительно в классе _DictShop_ переопределить метод:

```python
__setitem__()
```
с проверкой, что создаваемый ключ является объектом класса _Thing_.

Иначе, генерировать исключение:

```python
raise TypeError('ключами могут быть только объекты класса Thing')
```

Пример использования классов (эти строчки в программе не писать):

```python
th_1 = Thing('Лыжи', 11000, 1978.55)
th_2 = Thing('Книга', 1500, 256)
dict_things = DictShop()
dict_things[th_1] = th_1
dict_things[th_2] = th_2

for x in dict_things:
    print(x.name)

dict_things[1] = th_1 # исключение TypeError
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_5
### Объявите в программе следующие классы без содержимого (используйте оператор _pass_):

```python
Protists, Plants, Animals, Mosses, Flowering, Worms, Mammals, Human, Monkeys
```

и постройте схему наследования в соответствии со следующей иерархией древа жизни:

```
_здесь должна быть схема_
```

Затем, объявите в программе классы:

**Monkey** - наследуется от **Monkeys** и служит для описания обезьян;

**Person** - наследуется от **Human** и служит для описания человека;

**Flower** - наследуется от **Flowering** и служит для описания цветка;

**Worm** - наследуется от **Worms** и служит для описания червей.

Объекты этих классов должны создаваться командами:

```python
obj = Monkey(name, weight, old)
obj = Person(name, weight, old)
obj = Flower(name, weight, old)
obj = Worm(name, weight, old)
```

где _name_ - наименование (или имя) объекта (строка);

_weight_ - вес (вещественное число);

_old_ - возраст (целое число).

В каждом объекте любого из этих классов должны создаваться соответствующие атрибуты: _name_, _weight_, _old_.

Создайте в программе следующие объекты и сохраните их в виде списка _lst_objs_:

```python
Monkey: "мартышка", 30.4, 7
Monkey: "шимпанзе", 24.6, 8
Person: "Балакирев", 88, 34
Person: "Верховный жрец", 67.5, 45
Flower: "Тюльпан", 0.2, 1
Flower: "Роза", 0.1, 2
Worm: "червь", 0.01, 1
Worm: "червь 2", 0.02, 1
```

Затем, используя функции **isinstance()** и генератор списков (_List comprehensions_), сформируйте следующие списки из указанных объектов:

_lst_animals_ - все объекты, относящиеся к животным (**Animals**);

_lst_plants_ - все объекты, относящиеся к растениям (**Plants**);

_lst_mammals_ - все объекты, относящиеся к млекопитающим (**Mammals**).

P.S. В программе на экран выводить ничего не нужно.

## ex_6
### Известно, что с объектами класса _tuple_ можно складывать только такие же объекты (кортежи). Например:

```pyth
t1 = (1, 2, 3)
t2 = t1 + (4, 5) # (1, 2, 3, 4, 5)
```

Если же мы попытаемся прибавить любой другой итерируемый объект, например, список:

```pyth
t2 = t1 + [4, 5]
```

то возникнет ошибка.

Предлагается поправить этот функционал и создать свой собственный класс _Tuple_, унаследованный от базового класса _tuple_ и поддерживающий оператор:

```python
t1 = Tuple(iter_obj)
t2 = t1 + iter_obj  # создается новый объект класса Tuple с новым (соединенным) набором данных
```

где _iter_obj_ - любой итерируемый объект (список, словарь, строка, множество, кортеж и т.п.)

Пример использования класса (эти строчки в программе не писать):

```python
t = Tuple([1, 2, 3])
t = t + "Python"
print(t)   # (1, 2, 3, 'P', 'y', 't', 'h', 'o', 'n')
t = (t + "Python") + "ООП"
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_7
### Необходимо в программе объявить класс _VideoItem_ для представления одного видео (например, в youtube).

Объекты этого класса должны создаваться командой:

```python
video = VideoItem(title, descr, path)
```

где _title_ - заголовок видео (строка);

_descr_ - описание видео (строка);

_path_ - путь к видеофайлу.

В каждом объекте класса _VideoItem_ должны создаваться соответствующие атрибуты: _title_, _descr_, _path_.

Затем, нужно создать класс для формирования оценки видео в баллах от 0 до 5.

Для этого нужно объявить еще один класс с именем _VideoRating_, объекты которого создаются командой:

```python
rating = VideoRating()
```

В каждом объекте класса _VideoRating_ должен быть локальный приватный атрибут с именем ___rating_, содержащий целое число от 0 до 5 (по умолчанию 0).

А для записи и считывания значения из этого приватного атрибута должно быть объект-свойство (_property_) с именем _rating_.

Так как атрибут ___rating_ - это целое число в диапазоне _[0; 5]_, то в момент присвоения ему какого-либо значения необходимо проверять, что присваиваемое значение - целое число в диапазоне _[0; 5]_.

Если это не так, то генерировать исключение командой:

```python
raise ValueError('неверное присваиваемое значение')
```

Далее, в каждом объекте класса _VideoItem_ должен быть локальный атрибут _rating_ - объект класса _VideoRating_.

Пример использования классов (эти строчки в программе не писать):

```python
v = VideoItem('Курс по Python ООП', 'Подробный курс по Python ООР', 'D:/videos/python_oop.mp4')
print(v.rating.rating) # 0
v.rating.rating = 5
print(v.rating.rating) # 5
title = v.title
descr = v.descr
v.rating.rating = 6  # ValueError
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_9
### Объявите в программе базовый класс с именем _IteratorAttrs_ для перебора всех локальных атрибутов объектов класса.

Напомню, что для этого используются два магических метода:

**__iter__()** - для получения объекта-итератора (в данном случае - это сам объект _self_)

**__next__()** - для перебора локальных атрибутов объекта _self_ (используйте для этого словарь ___dict___)

Метод __next__() на каждой итерации должен возвращать кортеж в формате: _(имя атрибута, значение)_.

Подсказка: здесь можно определить один метод **__iter__()** как функцию-генератор.

Объявите дочерний класс _SmartPhone_, объекты которого создаются командой:

```python
phone = SmartPhone(model, size, memory)
```

где _model_ - модель смартфона (строка);

_size_ - габариты (ширина, длина) в виде кортежа двух чисел;

_memory_ - размер ОЗУ (памяти), как целое число.

В каждом объекте класса _SmartPhone_ должны создаваться соответствующие локальные атрибуты: _model_, _size_, _memory_.

Благодаря наследованию от базового класса _IteratorAttrs_, с объектами класса _SmartPhone_ должен выполняться оператор _for_:

```python
for attr, value in phone:
    print(attr, value)
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.
