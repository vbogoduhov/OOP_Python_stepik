# Распространение исключений (propagation exceptions)

## ex_3
### Объявите функцию с сигнатурой:

```python
def input_int_numbers(): ...
```

которая бы считывала строку из введенных целых чисел, записанных через пробел, и возвращала кортеж из введенных чисел (в виде целых чисел, а не строк).

Если хотя бы одно значение не является целым числом, то генерировать исключение, командой:

```python
raise TypeError('все числа должны быть целыми')
```

Вызовите эту функцию в цикле до тех пор, пока пользователь не введет в строке все целочисленные значения (то есть, цикл завершается, когда функция отработает штатно, без генерации исключения).

Выведите на экран прочитанные значения, записанные в виде строки через пробел.

## ex_4
### Объявите класс с именем _ValidatorString_, объекты которого создаются командой:

```python
vs = ValidatorString(min_length, max_length, chars)
```

где _min_length_, _max_length_ - минимально и максимально допустимая длина строки (целые числа, формируемые диапазон _[min_length; max_length]_);

_chars_ - строка из набора символов (хотя бы один из них должен присутствовать в проверяемой строке).

Если _chars_ - пустая строка, то проверку на вхождение символов не делать.


В самом классе _ValidatorString_ объявите метод:

```python
def is_valid(self, string): ...
```

который проверяет строку _string_ на соответствие критериям:

_string_ должна быть строкой, с длиной в диапазоне _[min_length; max_length]_ и в _string_ присутствует хотя бы один символ из _chars_.

Если хотя бы один из этих критериев не выполняется, то генерируется исключение командой:

```python
raise ValueError('недопустимая строка')
```

Затем, объявите класс с именем _LoginForm_, объекты которого создаются командой:

```python
lg = LoginForm(login_validator, password_validator)
```

где _login_validator_ - валидатор для логина (объект класса _ValidatorString_);

_password_validator_ - валидатор для пароля (объект класса _ValidatorString_).

В самом классе LoginForm объявите следующий метод:

```python
def form(self, request): ...
  ```


где _request_ - объект запроса (словарь).

В словаре _request_ должен быть ключ _'login'_ со значением введенного логина (строки) и ключ _'password'_ со значением введенного пароля (строка).

Если хотя бы одного ключа нет, то генерировать исключение командой:

```python
raise TypeError('в запросе отсутствует логин или пароль')
```

В противном случае (если проверка для request прошла), проверять корректность полученного формой логина и пароля с помощью валидаторов, указанных в параметрах _login_validator_ и _password_validator_, при создании объекта формы.

Если логин/пароль введены верно, то в объекте класса _LoginForm_ локальным атрибутам _login и _password присвоить соответствующие значения.

Пример использования классов (эти строчки должны быть в программе):

```python
login_v = ValidatorString(4, 50, "")
password_v = ValidatorString(10, 50, "!$#@%&?")
lg = LoginForm(login_v, password_v)
login, password = input().split()
try:
    lg.form({'login': login, 'password': password})
except (TypeError, ValueError) as e:
    print(e)
else:
    print(lg._login)
  ```



## ex_5
### Вы начинаете разрабатывать свой сервис по тестированию.
Для этого вам поручается разработать базовый класс _Test_ для всех видов тестов, объекты которого создаются командой:

```python
test = Test(descr)
```

где _descr_ - формулировка теста (строка).

Если длина строки _descr_ меньше 10 или больше 10 000 символов, то генерировать исключение командой:

```python
raise ValueError('формулировка теста должна быть от 10 до 10 000 символов')
```

В самом классе _Test_ должен быть объявлен абстрактный метод:


```python
def run(self): ...
  ```

который должен быть переопределен в дочернем классе.

Если это не так, то должно генерироваться исключение командой:

```python
raise NotImplementedError
```

Далее, объявите дочерний класс с именем _TestAnsDigit_ для тестирования правильного введенного числового ответа на вопрос теста.

Объекты класса _TestAnsDigit_ должны создаваться командой:

```python
test_d = TestAnsDigit(descr, ans_digit, max_error_digit)
```

где _ans_digit_ - верный числовой ответ на тест;

_max_error_digit_ - максимальная погрешность в указании числового ответа (необходимо для проверки корректности вещественных чисел, по умолчанию принимает значение 0.01).

Если аргумент _ans_digit_ или _max_error_digit_ не число (также проверить, что _max_error_digit_ больше или равно нулю), то генерировать исключение командой:

```python
raise ValueError('недопустимые значения аргументов теста')
```

В классе _TestAnsDigit_ переопределите метод:

```python
def run(self): ...
```

который должен читать строку из входного потока (ответ пользователя) командой:

```python
ans = float(input()) # именно такой командой, ее прописывайте в методе run()
```

и возвращать булево значение _True_, если введенный числовой ответ _ans_ принадлежит диапазону _[ans_digit-max_error_digit; ans_digit+max_error_digit]_.

Иначе возвращается булево значение _False_.

Теперь нужно воспользоваться классом _TestAnsDigit_.

Для этого в программе вначале читается сам тест с помощью команд:

```python
descr, ans = map(str.strip, input().split('|'))  # например: Какое значение получится при вычислении 2+2? | 4
ans = float(ans) # здесь для простоты полагаем, что ans точно число и ошибок в преобразовании быть не может
```

Далее, вам необходимо создать объект класса _TestAnsDigit_ с аргументами _descr_, _ans_, а аргумент _max_error_digit_ должен принимать значение по умолчанию 0.01.

Запустите тест командой _run()_ и выведите на экран результат его работы (значение _True_ или _False_).

Если в процессе создания объекта класса _TestAnsDigit_ или в процессе работы метода _run()_ возникли исключения, то они должны быть обработаны и на экран выведено сообщение, содержащееся в исключении.

## ex_6
### В программе выполняется считывание числовых данных из входного потока, командой:

```python
digits = list(map(float, input().split()))
```

Эти данные следует представить в виде объекта класса _TupleLimit_.

Сам класс должен наследоваться от класса _tuple_, а его объекты создаваться командой:

```python
tl = TupleLimit(lst, max_length)
```

где _lst_ - коллекция (список или кортеж) из данных; 

_max_length_ - максимально допустимая длина коллекции _TupleLimit_.

Если длина _lst_ превышает значение _max_length_, то должно генерироваться исключение командой:

```python
raise ValueError('число элементов коллекции превышает заданный предел')
```

В самом классе _TupleLimit_ переопределить магические методы __str__() и __repr__() для отображения объекта класса _TupleLimit_ в виде строки из набора данных _lst_, записанных через пробел. Например:

```python
"1.0 2.5 -5.0 11.2
```


Создайте в программе объект класса _TupleLimit_ для прочитанных данных _digits_ и параметром _max_length = 5_.
Выведите на экран объект в случае его успешного создания. Иначе, выведите сообщение обработанного исключения.
