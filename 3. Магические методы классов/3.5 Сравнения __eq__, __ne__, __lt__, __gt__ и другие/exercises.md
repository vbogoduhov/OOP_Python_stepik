# Сравнения __eq__, __ne__, __lt__, __gt__ и другие
## ex_3
### Объявите класс _Track_ (маршрут), объекты которого создаются командой:

```python
track = Track(start_x, start_y)
```

где _start_x_, _start_y_ - координаты начала маршрута (целые или вещественные числа).

Каждый линейный сегмент маршрута определяется классом _TrackLine_, объекты которого создаются командой:

```python
line = TrackLine(to_x, to_y, max_speed)
```

где _to_x_, _to_y_ - координаты следующей точки маршрута (целые или вещественные числа); 

_max_speed_ - максимальная скорость на данном участке (целое число).

Для формирования и работы с маршрутом в классе _Track_ должны быть объявлены следующие методы:

**add_track(self, tr)** - добавление линейного сегмента маршрута (следующей точки);

**get_tracks(self)** - получение кортежа из объектов класса _TrackLine_.

Также для объектов класса _Track_ должны быть реализованные следующие операции сравнения:

```python
track1 == track2  # маршруты равны, если равны их длины
track1 != track2  # маршруты не равны, если не равны их длины
track1 > track2  # True, если длина пути для track1 больше, чем для track2
track1 < track2  # True, если длина пути для track1 меньше, чем для track2
```

И функция:

```python
n = len(track) # возвращает целочисленную длину маршрута (привести к типу int) для объекта track2
```

Создайте два маршрута _track1_ и _track2_ с координатами:

```python
1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90
```

Сравните их между собой на равенство. Результат сравнения сохраните в переменной _res_eq_.

P.S. На экран в программе ничего выводить не нужно.

## ex_4
### Объявите класс _Dimensions_ (габариты) с атрибутами:

```python
MIN_DIMENSION = 10
MAX_DIMENSION = 10000
```

Каждый объект класса _Dimensions_ должен создаваться командой:

```python
d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
```

Значения _a_, _b_, _c_ должны сохраняться в локальных приватных атрибутах __a, __b, __c объектах этого класса.

Для изменения и доступа к приватным атрибутам в классе _Dimensions_ должны быть объявлены объекты-свойства (property) с именами: 

_a_, _b_, _c_. 

Причем, в момент присваивания нового значения должна выполняться проверка попадания числа в диапазон _[MIN_DIMENSION; MAX_DIMENSION]_. 
Если число не попадает, то оно игнорируется и существующее значение не меняется.

С объектами класса _Dimensions_ должны выполняться следующие операторы сравнения:

```python
dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```

Объявите в программе еще один класс с именем _ShopItem_ (товар), объекты которого создаются командой:

item = ShopItem(name, price, dim)dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```python
dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
dim1 > dim2    # True, если объем dim1 больше объема dim2
dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
dim1 < dim2    # True, если объем dim1 меньше объема dim2
```

где 

_name_ - название товара (строка); 

_price_ - цена товара (целое или вещественное число); 

_dim_ - габариты товара (объект класса Dimensions).

В каждом объекте класса _ShopItem_ должны создаваться локальные атрибуты:

_name_ - название товара;

_price_ - цена товара;

_dim_ - габариты товара (объект класса _Dimensions_).

Создайте список с именем _lst_shop_ из четырех товаров со следующими данными:

```
- кеды; 1024; (40, 30, 120)
- зонт; 500.24; (10, 20, 50)
- холодильник; 40000; (2000, 600, 500)
- табуретка; 2000.99; (500, 200, 200)
```


Сформируйте новый список _lst_shop_sorted_ с упорядоченными по возрастанию объема (габаритов) товаров списка _lst_shop_, используя стандартную функцию _sorted()_ языка _Python_ 
и ее параметр _key_ для настройки сортировки. 
Прежний список _lst_shop_ должен оставаться без изменений.

P.S. На экран в программе ничего выводить не нужно.

## ex_5
### Имеется стихотворение, представленное следующим списком строк:

```python
stich = ["Я к вам пишу – чего же боле?",
        "Что я могу еще сказать?",
        "Теперь, я знаю, в вашей воле",
        "Меня презреньем наказать.",
        "Но вы, к моей несчастной доле",
        "Хоть каплю жалости храня,",
        "Вы не оставите меня."]
```

Необходимо в каждой строчке этого стиха убрать символы _"–?!,.;"_ в начале и в конце каждого слова и разбить строку по словам 
(слова разделяются одним или несколькими пробелами). 
На основе полученного списка слов, создать объект класса _StringText_ командой:

```python
st = StringText(lst_words)
```

где _lst_words_ - список из слов одной строчки стихотворения. 

С объектами класса _StringText_ должны быть реализованы операторы сравнения:

```python
st1 > st2   # True, если число слов в st1 больше, чем в st2
st1 >= st2  # True, если число слов в st1 больше или равно st2
st1 < st2   # True, если число слов в st1 меньше, чем в st2
st1 <= st2  # True, если число слов в st1 меньше или равно st2
```

Все объекты класса _StringText_ (для каждой строчки стихотворения) сохранить в списке _lst_text_.
Затем, сформировать новый список _lst_text_sorted_ из отсортированных объектов класса _StringText_ по убыванию числа слов.
Для сортировки использовать стандартную функцию **sorted()** языка _Python_. 
После этого преобразовать данный список (_lst_text_sorted_) в список из строк (объекты заменяются на соответствующие строки, между словами ставится пробел).

P.S. На экран в программе ничего выводить не нужно.

## ex_6
### Ваша задача написать программу поиска слова в строке.

Задача усложняется тем, что слово должно определяться в разных его формах. Например, слово:

```программирование
```

может иметь следующие формы:

```программирование, программированию, программированием, программировании, программирования, программированиям, программированиями, программированиях```


Для решения этой задачи необходимо объявить класс _Morph_ (морфология), объекты которого создаются командой:

```python
mw = Morph(word1, word2, ..., wordN)
```

где _word1, word2, ..., wordN_ - возможные формы слова.

В классе _Morph_ реализовать методы:

**add_word(self, word)** - добавление нового слова (если его нет в списке слов объекта класса _Morph_);

**get_words(self)** - получение кортежа форм слов.

Также с объектами класса _Morph_ должны выполняться следующие операторы сравнения:

```python
mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)
```

И аналогичная пара сравнений:

```python
"word" == mw1
"word" != mw1
```

После создания класса _Morph_, формируется список _dict_words_ из объектов этого класса, для следующих слов с их словоформами:

- связь, связи, связью, связей, связям, связями, связях
- формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
- вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
- эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
- день, дня, дню, днем, дне, дни, дням, днями, днях

Затем, прочитайте строку из входного потока командой:

```python
text = input()
```

Найдите все вхождения слов из списка _dict_words_ (используя операторы сравнения) в строке _text_ (без учета регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.
