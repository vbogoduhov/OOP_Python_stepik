# Наследование. Функция super() и делегирование

## ex_3
### Ранее вы уже использовали делегирование методов, когда вызывали инициализатор базового класса через функцию _super()_.

Чаще всего делегирование в _Python_ связано с вызовом магических методов базовых классов (так как их имена нельзя менять).

Выполним такой пример.

Объявите в программе базовый класс с именем _Book_, объекты которого создаются командой:

```python
book = Book(title, author, pages, year)
```

где _title_ - заголовок книги (строка);

_author_ - автор книги (строка);

_pages_ - число страниц (целое число);

_year_ - год издания (целое число).

В каждом объекте класса _Book_ должны формироваться соответствующие локальные атрибуты: _title_, _author_, _pages_, _year_.

Объявите дочерний класс _DigitBook_ от класса _Book_, объекты которого создаются командой:

```python
db = DigitBook(title, author, pages, year, size, frm)
```

где дополнительные параметры _size_ - размер книги в байтах (целое число);

_frm_ - формат книги (строка: 'pdf', 'doc', 'fb2', 'txt').

В каждом объекте класса _DigitBook_ должны формироваться соответствующие локальные атрибуты: _title_, _author_, _pages_, _year_, _size_, _frm_.

Инициализация локальных атрибутов _title_, _author_, _pages_, _year_ должна выполняться в базовом классе _Book_, а параметры _size_, _frm_ инициализируются в дочернем классе _DigitBook_.

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.
