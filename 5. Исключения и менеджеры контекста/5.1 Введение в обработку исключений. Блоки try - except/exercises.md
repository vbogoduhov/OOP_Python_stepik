# Введение в обработку исключений. Блоки try / except

## ex_5
### В программе объявлен класс _Point_:

```python
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y
```

И создается объект этого класса:

```python
pt = Point(1, 2)
```

Далее, вам нужно обратиться к атрибуту _z_ объекта _pt_ и, если такой атрибут существует, то вывести его значение на экран.

Иначе вывести строку (без кавычек):

```python
"Атрибут с именем z не существует"
```
Реализовать проверку следует с помощью блоков _try/except_.

Подсказка: при обращении к несуществующему атрибуту генерируется исключение _AttributeError_.

## ex_7
### В программе вводятся в одну строчку через пробел некоторые данные, например:

```python
"1 -5.6 2 abc 0 False 22.5
```
Эти данные разбиваются по пробелу и представляются в виде списка строк:

```python
lst_in = input().split()
```

Ваша задача посчитать сумму всех целочисленных значений, присутствующих в списке _lst_in_.

Результат (сумму) вывести на экран.

Подсказка: отбор только целочисленных значений можно выполнить с помощь функции _filter()_ с последующим их преобразованием в целые числа с помощью функции _map()_ и, затем, вычислением их суммы с помощью функции _sum()_.

Для отбора целочисленных значений рекомендуется объявить вспомогательную функцию, которая бы возвращала _True_ для строк, в которых присутствует целое число и _False_ - для всех остальных строк.

## ex_8
### В программе вводятся в одну строчку через пробел некоторые данные, например:

```python
"1 -5.6 True abc 0 23.56 hello"
```
Эти данные разбиваются по пробелу и представляются в виде списка строк:

```python
lst_in = input().split()
```
Ваша задача сформировать новый список с именем _lst_out_, в котором строки с целыми числами будут представлены как целые числа (тип _int_), строки с вещественными числами, как вещественные (тип _float_), а остальные данные - без изменений.

Например:
```pythonlst_out = [1, -5.6, 'True', 'abc', 0, 23.56, 'hello']  # после обработки введенной строки "1 -5.6 True abc 0 23.56 hello"
```
Реализовать эту задачу следует с помощью функции _map()_ и объявления вспомогательной функции с механизмом обработки исключений для непосредственного преобразования данных в целые или вещественные числа.

P.S. В программе нужно только сформировать список _lst_out_. На экран ничего выводить не нужно.

## ex_9
### Объявите в программе класс _Triangle_, объекты которого создаются командой:

```python
tr = Triangle(a, b, c)
```

где _a_, _b_, _c_ - длины сторон треугольника (любые положительные числа).

В каждом объекте класса _Triangle_ должны формироваться локальные атрибуты _a, _b, _c с соответствующими значениями.

Если в качестве хотя бы одной величины _a_, _b_, _c_ передается не числовое значение, или меньше либо равно нулю, то должно генерироваться исключение командой:

```python
raise TypeError('стороны треугольника должны быть положительными числами')
```

Если из переданных значений _a_, _b_, _c_ нельзя составить треугольник (условие: каждая сторона должна быть меньше суммы двух других), то генерировать исключение командой:

```python
raise ValueError('из указанных длин сторон нельзя составить треугольник')
```

Затем, на основе следующего набора данных:

```python
input_data = [(1.0, 4.54, 3), ('abc', 1, 2, 3), (-3, 3, 5.2), (4.2, 5.7, 8.7), (True, 3, 5), (7, 4, 6)]
```

необходимо сформировать объекты класса _Triangle_, но только в том случае, если не возникло никаких исключений.

Все созданные объекты представить в виде списка с именем _lst_tr_.

P.S. В программе нужно только сформировать список _lst_tr_. На экран ничего выводить не нужно.

## ex_10
### Объявите в программе класс _FloatValidator_, объекты которого создаются командой:

```python
fv = FloatValidator(min_value, max_value)
```
где _min_value_, _max_value_ - минимальное и максимальное допустимое значение (диапазон _[min_value; max_value]_).

Объекты этого класса предполагается использовать следующим образом:

```python
fv(value)
```

где _value_ - проверяемое значение.

Если _value_ не вещественное число или не принадлежит диапазону _[min_value; max_value]_, то генерируется исключение командой:

```python
raise ValueError('значение не прошло валидацию')
```

По аналогии, объявите класс _IntegerValidator_, объекты которого создаются командой:

```python
iv = IntegerValidator(min_value, max_value)
```

и используются командой:

```python
iv(value)
```

Здесь также генерируется исключение:

```python
raise ValueError('значение не прошло валидацию')
```

если _value_ не целое число или не принадлежит диапазону _[min_value; max_value]_.

После этого объявите функцию с сигнатурой:

```python
def is_valid(lst, validators): ...
  ```


где _lst_ - список из данных;

_validators_ - список из объектов-валидаторов (объектов классов _FloatValidator_ и _IntegerValidator_).

Эта функция должна отбирать из списка все значения, которые прошли хотя бы по одному валидатору. И возвращать новый список с элементами, прошедшими проверку.

Пример использования классов и функции (эти строчки в программе не писать):
```python
fv = FloatValidator(0, 10.5)
iv = IntegerValidator(-10, 20)
lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])   # [1, 4.5]
```

