# Наследование в объектно-ориентированном программировании
## ex_4
### Наследование часто используют, чтобы вынести общий код дочерних классов в базовый класс.

Сделаем такой пример. Объявите в программе базовый класс _Animal_ (животное), объекты которого можно создать командой:

```python
an = Animal(name, old)
```

где _name_ - название животного (строка); 
_old_ - возраст животного (целое число). 

Такие же локальные атрибуты (_name_ и _old_) должны создаваться в объектах класса.

Далее, объявите дочерний класс (от базового _Animal_) с именем _Cat_ (кошки), объекты которого создаются командой:

```python
cat = Cat(name, old, color, weight)
```

где _name_, _old_ - те же самые параметры, что и в базовом классе; 

_color_ - цвет кошки (строка); 

_weight_ - вес кошки (любое положительное число).

В объектах класса _Cat_ должны автоматически формироваться локальные атрибуты: _name_, _old_, _color_, _weight_. 

Формирование атрибутов _name_, _old_ должен выполнять инициализатор базового класса. 

По аналогии объявите еще один дочерний класс _Dog_ (собака), объекты которого создаются командой:

```python
dog = Dog(name, old, breed, size)
```

здесь _name_, _old_ - те же самые параметры, что и в базовом классе;

_breed_ - порода собаки (строка);

_size_ - кортеж в формате (_height_, _length_) высота и длина - числа.

В объектах класса _Dog_ по аналогии должны формироваться локальные атрибуты: _name_, _old_, _breed_, _size_.

За формирование атрибутов _name_, _old_ отвечает инициализатор базового класса.

Наконец, в классах _Cat_ и _Dog_ объявите метод:

**get_info()** - для получения информации о животном.

Этот метод должен возвращать строку в формате:

```python
"name: old, <остальные параметры через запятую>"
```

Например, для следующего объекта класса _Cat_:

```python
cat = Cat('кот', 4, 'black', 2.25)
```

метод _get_info_ должен вернуть строку:

```python
"кот: 4, black, 2.25"
```

P.S. В программе достаточно объявить три класса. Выводить на экран ничего не нужно.

## ex_5
### Иногда наследование используют, чтобы наделить объекты дочерних классов определенным набором атрибутов. 

Сделаем такой пример.

Предположим, вы разрабатываете программу для интернет-магазина.
В этом магазине могут быть как реальные (физические) товары, так и электронные.
Для этих двух групп, очевидно, нужен разный набор атрибутов:

- для реальных физических товаров: _id_, _name_, _price_, _weight_, _dims_

где _id_ - идентификатор товара (целое число);

_name_ - наименование товара (строка);

_price_ - цена товара (вещественное число); 

_weight_ - вес товара (вещественное число); 

_dims_ = _(lenght, width, depth)_ - длина, ширина, глубина - габариты товара (вещественные числа);

- для электронных товаров: _id_, _name_, _price_, _memory_, _frm_

где _id_ - идентификатор товара (целое число); 

_name_ - наименование товара (строка); 

_price_ - цена товара (вещественное число); 

_memory_ - занимаемый размер (в байтах - целое число); 

_frm_ - формат данных (строка: _pdf_, _docx_ и т.п.)

Так как все товары могут идти вперемешку, то мы хотим, чтобы в каждом объекте (для товара) присутствовали все атрибуты:

```python
id, name, price, weight, dims, memory, frm
```

с начальными значениями _None_. 

А уже, затем, нужным из них будут присвоены конкретные данные.

Для реализации этой логики объявите в программе базовый класс с именем _Thing_ (вещь, предмет), объекты которого могут создаваться командой:

```python
th = Thing(name, price)
```

А атрибут _id_ должен формироваться автоматически и быть уникальным для каждого товара (например, можно для каждого нового объекта увеличивать на единицу).

В объектах класса _Thing_ должен формироваться полный набор локальных атрибутов (_id_, _name_, _price_, _weight_, _dims_, _memory_, _frm_) со значением _None_, кроме атрибутов: _id_, _name_, _price_.

Далее, нужно объявить два дочерних класса:

**Table** - для столов;

**ElBook** - для электронных книг.

Объекты этих классов должны создаваться командами:

```python
table = Table(name, price, weight, dims)
book = ElBook(name, price, memory, frm)
```


Причем, атрибуты _name_, _price_ (а также _id_) следует инициализировать в базовом классе, т.к. они общие для всех товаров. 

Остальные атрибуты должны либо принимать значение _None_, если не используются, либо инициализироваться конкретными значениями уже в дочерних классах.

Наконец, в базовом классе _Thing_ объявите метод:

**get_data()** - для получения кортежа в формате (_id_, _name_, _price_, _weight_, _dims_, _memory_, _frm_)

Пример использования классов (эти строчки в программе писать не нужно):

```python
table = Table("Круглый", 1024, 812.55, (700, 750, 700))
book = ElBook("Python ООП", 2000, 2048, 'pdf')
print(*table.get_data())
print(*book.get_data())
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.



## ex_7
### С помощью наследования можно как бы "наполнять" дочерние классы нужными качествами (свойствами).

Как пример, объявите в программе класс с именем:

```python
Singleton
```

который бы позволял создавать только один экземпляр (все последующие экземпляры должны ссылаться на первый).

Как это делать, вы должны уже знать из этого курса.

Затем, объявите еще один класс с именем:

```python
Game
```

который бы наследовался от класса _Singleton_. Объекты класса Game должны создаваться командой:

```python
game = Game(name)
```

где _name _- название игры (строка).

В каждом объекте класса Game должен создаваться атрибут name с соответствующим содержимым.

Убедитесь, что атрибут _name_ принимает значение первого созданного объекта (если это не так, то поправьте инициализатор дочернего класса, чтобы это условие выполнялось).

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

## ex_8
### Вам необходимо создать множество классов для валидации (проверки) корректности данных.

Для этого ваш непосредственный начальник (Senior) предлагает вам объявить в программе базовый класс с именем:

```python
Validator
```

обеспечивающий базовый функционал для проверки корректности данных.

В частности, в этом классе нужно объявить следующий метод:

```python
def _is_valid(self, data): ...
```

По задумке этот метод должен возвращать булево значение _True_, если данные (_data_) корректны и _False_ - в противном случае.

Так как базовый класс _Validator_ - это общий класс для всех видов проверок, то метод __is_valid()_ будет просто возвращать _True_.
Кроме того, объекты класса _Validator_:

```python
v = Validator()   # инициализатор в классе Validator прописывать не нужно
```

должны вызываться подобно функциям:

```python
v(data)
```

Если значение _data_ корректно, то оно возвращается, иначе генерируется исключение:

Проверка корректности выполняется с помощью метода __is_valid()_. 

После этого, в программе нужно объявить два дочерних класса:

**IntegerValidator** - для проверки, что _data_ - целое число в заданном диапазоне;

**FloatValidator** - для проверки, что _data_ - вещественное число в заданном диапазоне.

Объекты этих классов предполагается создавать командами:

```python
integer_validator = IntegerValidator(min_value, max_value)
float_validator = FloatValidator(min_value, max_value)
```

где _min_value_, _max_value_ - допустимый диапазон чисел _[min_value; max_value]_

Также в этих классах нужно переопределить метод:

```python
def _is_valid(self, data): ...
```

который бы возвращал _True_, если _data_ является числом верного типа (либо _int_, либо _float_ в зависимости от валидатора) и находится в заданном диапазоне _[min_value; max_value]_. 
Иначе, возвращается _False_.

Пример использования классов (эти строчки в программе писать не нужно):

```python
integer_validator = IntegerValidator(-10, 10)
float_validator = FloatValidator(-1, 1)
res1 = integer_validator(10)  # исключение не генерируется (проверка проходит)
res2 = float_validator(10)    # исключение ValueError
```

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
