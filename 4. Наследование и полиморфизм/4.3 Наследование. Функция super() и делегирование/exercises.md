# Наследование. Функция super() и делегирование

## ex_3
### Ранее вы уже использовали делегирование методов, когда вызывали инициализатор базового класса через функцию _super()_.

Чаще всего делегирование в _Python_ связано с вызовом магических методов базовых классов (так как их имена нельзя менять).

Выполним такой пример.

Объявите в программе базовый класс с именем _Book_, объекты которого создаются командой:

```python
book = Book(title, author, pages, year)
```

где _title_ - заголовок книги (строка);

_author_ - автор книги (строка);

_pages_ - число страниц (целое число);

_year_ - год издания (целое число).

В каждом объекте класса _Book_ должны формироваться соответствующие локальные атрибуты: _title_, _author_, _pages_, _year_.

Объявите дочерний класс _DigitBook_ от класса _Book_, объекты которого создаются командой:

```python
db = DigitBook(title, author, pages, year, size, frm)
```

где дополнительные параметры _size_ - размер книги в байтах (целое число);

_frm_ - формат книги (строка: 'pdf', 'doc', 'fb2', 'txt').

В каждом объекте класса _DigitBook_ должны формироваться соответствующие локальные атрибуты: _title_, _author_, _pages_, _year_, _size_, _frm_.

Инициализация локальных атрибутов _title_, _author_, _pages_, _year_ должна выполняться в базовом классе _Book_, а параметры _size_, _frm_ инициализируются в дочернем классе _DigitBook_.

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_4
### Создается программа по учету склада.

Каждый предмет на складе должен описываться базовым классом _Thing_.

Объекты этого класса создаются командой:

```python
th1 = Thing(name, weight)
```

где _name_ - наименование предмета (строка);

_weight_ - вес предмета (вещественное число).

Для описания каждого конкретного вида предметов, создаются дочерние классы (на основе базового _Thing_):

**ArtObject** - для представления арт-объектов;

**Computer** - для системных блоков компьютеров;

**Auto** - для автомобилей.

Объекты этих классов создаются командами:

```python
obj = ArtObject(name, weight, author, date)  # author - автор (строка); date - дата создания (строка)
obj = Computer(name, weight, memory, cpu)    # memory - размер памяти (целое число); cpu - тип процессора (строка)
obj = Auto(name, weight, dims)               # dims - габариты, кортеж (width, length, height) - вещественные или целые числа
```

На основе класса Auto создаются дочерние классы _Mercedes_ и _Toyota_, объекты которых определяются командами:

```python
auto = Mercedes(name, weight, dims, model, old) # model - модель (строка); old - время использования, в годах (целое число)
auto = Toyota(name, weight, dims, model, wheel) # model - модель (строка); wheel - тип руля: True - леворульный, False - праворульный
```

Во всех объектах классов должны создаваться соответствующие локальные атрибуты: _name_, _weight_ и т.д.

Инициализация атрибутов должна выполняться в соответствующих классах (не должно быть дублирования кода).

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_5
### Вам поручено организовать представление объектов для продажи в риэлтерских агентствах.

Для этого в программе нужно объявить базовый класс _SellItem_, объекты которого создаются командой:

```python
item = SellItem(name, price)
```

где _name_ - название объекта продажи (строка);

_price_ - цена продажи (число: целое или вещественное).

Каждые конкретные типы объектов описываются следующими классами, унаследованные от базового _SellItem_:

**House** - дома;

**Flat** - квартиры;

**Land** - земельные участки.

Объекты этих классов создаются командами:

```python
house = House(name, price, material, square)
flat = Flat(name, price, size, rooms)
land = Land(name, price, square)
```
В каждом объекте этих классов должны формироваться соответствующие локальные атрибуты: _name_, _price_ и т.д.

Формирование атрибутов _name_ и _price_ должно выполняться в инициализаторе базового класса.

Далее, объявить еще один класс с именем _Agency_, объекты которого создаются командой:

```python
ag = Agency(name
```

где _name_ - название агентства (строка).

В классе _Agency_ объявить следующие методы:

**add_object(obj)** - добавление нового объекта недвижимости для продажи (один из объектов классов: _House_, _Flat_, _Land_);

**remove_object(obj)** - удаление объекта _obj_ из списка объектов для продажи;

**get_objects()** - возвращает список из всех объектов для продажи.

Пример использования классов (эти строчки в программе не писать):

```python
ag = Agency("Рога и копыта")
ag.add_object(Flat("квартира, 3к", 10000000, 121.5, 3))
ag.add_object(Flat("квартира, 2к", 8000000, 74.5, 2))
ag.add_object(Flat("квартира, 1к", 4000000, 54, 1))
ag.add_object(House("дом, крипичный", price=35000000, material="кирпич", square=186.5))
ag.add_object(Land("участок под застройку", 3000000, 6.74))
for obj in ag.get_objects():
    print(obj.name)

lst_houses = [x for x in ag.get_objects() if isinstance(x, House)] # выделение списка домов
````

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_6
### Ваша команда создает небольшой фреймворк для веб-сервера.

Для этого был объявлен класс:

```python
class Router:
    app = {}

    @classmethod
    def get(cls, path):
        return cls.app.get(path)

    @classmethod
    def add_callback(cls, path, func):
        cls.app[path] = func
```

И его предполагается использовать следующим образом:

```python
@Callback('/', Router)
def index():
    return '<h1>Главная</h1>'


route = Router.get('/')
if route:
    ret = route()
    print(ret)
```

Здесь _Callback_ - это класс-декоратор с параметрами: _path = '/' - маршрут_; 

_router_cls = Router - класс роутера_. 

Декоратор _Callback_ должен обеспечивать добавление функции (в примере _index_) в словарь _app- класса _Router_.

Ключом словаря выступает маршрут (_path_), а значением - ссылка на декорируемую функцию.

Для этого следует использовать метод _add_callback_ класса _Router_.

Затем, из роутера (_Router_) методом _get_ выбирается ранее добавленная функция (в примере _index_), и если она существует, то вызывается с выводом результата в консоль.

Ваша задача реализовать класс-декоратор _Callback_. 

Небольшая справка.

Для реализации декоратора с параметрами на уровне класса в инициализаторе __init__(self, methods) прописываем параметр для декоратора, а магический метод __call__() объявляем для декорирования функции:

```python
class Handler:
    def __init__(self, path, route_cls):
        # здесь нужные строчки

    def __call__(self, func):
        # здесь строчки 
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.

## ex_7
### В программе объявлена функция _integer_params_ для класса _Vector_, которая применяет к каждому методу класса декоратор _integer_params_decorated_:

```python
def integer_params(cls):
    methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
    for k, v in methods.items():
        setattr(cls, k, integer_params_decorated(v))

    return cls


@integer_params
class Vector:
    def __init__(self, *args):
        self.__coords = list(args)

    def __getitem__(self, item):
        return self.__coords[item]

    def __setitem__(self, key, value):
        self.__coords[key] = value

    def set_coords(self, *coords, reverse=False):
        c = list(coords)
        self.__coords = c if not reverse else c[::-1]
```

Декоратор _integer_params_decorated_ должен проверять, чтобы все передаваемые аргументы в методы класса (кроме первого _self_) были целыми числами (имели тип _int_).

Если это не так, то должно генерироваться исключение командой:

```python
raise TypeError("аргументы должны быть целыми числами")
```

Ваша задача объявить эту функцию-декоратор.

Пример использования класса (эти строчки в программе не писать):

```python
vector = Vector(1, 2)
print(vector[1])
vector[1] = 20.4 # TypeError
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_8
### Объявите класс _SoftList_, который наследуется от стандартного класса _list_.

В классе _SoftList_ следует объявить необходимые магические методы так, 

чтобы при обращении к несуществующему элементу (по индексу) 

возвращалось значение _False_ (а не исключение _Out of Range_). Например:

```python
sl = SoftList("python")
sl[0] # 'p'
sl[-1] # 'n'
sl[6] # False
sl[-7] # False
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_9
### Объявите класс _StringDigit_, который наследуется от стандартного класса _str_.

Объекты класса _StringDigit_ должны создаваться командой:

```python
sd = StringDigit(string)
```

где _string_ - строка из цифр (например, "12455752345950").

Если в строке _string_ окажется хотя бы один не цифровой символ, то генерировать исключение командой:

```python
raise ValueError("в строке должны быть только цифры")
```

Также в классе _StringDigit_ нужно переопределить оператор + (конкатенации строк) так, чтобы операции:

```python
sd = sd + "123"
sd = "123" + sd
```

создавали новые объекты класса _StringDigit_ (а не класса _str_).

Если же при соединении строк появляется не цифровой символ, то генерировать исключение:

```python
raise ValueError("в строке должны быть только цифры")
```

Пример использования класса (эти строчки в программе не писать):

```python
sd = StringDigit("123")
print(sd)       # 123
sd = sd + "456" # StringDigit: 123456
sd = "789" + sd # StringDigit: 789123456
sd = sd + "12f" # ValueError
```

P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.

## ex_10
### Объявите базовый класс с именем _ItemAttrs_, который бы позволял обращаться к локальным атрибутам объектов дочерних классов по индексу.

Для этого в классе ItemAttrs нужно переопределить следующие методы:

**__getitem__()** - для получения значения атрибута по индексу;

**__setitem__()** - для изменения значения атрибута по индексу.

Объявите дочерний класс _Point_ для представления координаты точки на плоскости.

Объекты этого класса должны создаваться командой:

```python
pt = Point(x, y)
```

где _x_, _y_ - целые или вещественные числа.

Пример использования классов (эти строчки в программе не писать):

```python
pt = Point(1, 2.5)
x = pt[0]   # 1
y = pt[1]   # 2.5
pt[0] = 10
```

P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.
