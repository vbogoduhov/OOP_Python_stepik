# 1.5 Инициализатор \_\_init\_\_ и финализатор \_\_end\_\_

## ex. 2. 
**Объявите класс _Money_ так, чтобы объекты этого класса можно было создавать следующим образом:**

```python
my_money = Money(100)
your_money = Money(1000)
```

Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте) _money_ каждого экземпляра класса.

## ex. 3. 
**Объявите класс _Point_ так, чтобы объекты этого класса можно было создавать командами:**

```python
p1 = Point(10, 20)
p2 = Point(12, 5, 'red')
```

Здесь первые два значения - это координаты точки на плоскости (локальные свойства _x_, _y_), а третий необязательный аргумент - цвет точки (локальное свойство _color_). Если цвет не указывается, то он по умолчанию принимает значение _black_.

Создайте тысячу таких объектов с координатами _(1, 1), (3, 3), (5, 5), ..._ то есть, с увеличением на два для каждой новой точки. Каждый объект следует поместить в список _points_ (по порядку). Для второго объекта в списке _points_ укажите цвет _'yellow'_.

## ex. 4. 
**Объявите три класса геометрических фигур: _Line_, _Rect_, _Ellipse_. Должна быть возможность создавать объекты каждого класса следующими командами:**

```python
g1 = Line(a, b, c, d)
g2 = Rect(a, b, c, d)
g3 = Ellipse(a, b, c, d)
```

Здесь в качестве аргументов _a_, _b_, _c_, _d_ передаются координаты верхнего правого и нижнего левого углов (произвольные числа). В каждом объекте координаты должны сохраняться в локальных свойствах _sp_ (верхний правый угол) и _ep_ (нижний левый) в виде кортежей _(a, b)_ и _(c, d)_ соответственно.

Сформируйте __217 объектов__ этих классов:

для каждого текущего объекта класс выбирается случайно (или _Line_, или _Rect_, или _Ellipse_). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке _elements_.

В списке _elements_ обнулите координаты объектов только для класса _Line_.

## ex. 5. 
**Объявите класс _TriangleChecker_, объекты которого можно было бы создавать командой:**

```python
tr = TriangleChecker(a, b, c)
```

Здесь _a_, _b_, _c_ - длины сторон треугольника.

В классе _TriangleChecker_ необходимо объявить метод _is_triangle()_, который бы возвращал следующие коды:

- 1 - если хотя бы одна сторона не число (не _float_ или _int_) или хотя бы одно число меньше или равно нулю;

- 2 - указанные числа _a_, _b_, _c_ не могут являться длинами сторон треугольника;

- 3 - стороны _a_, _b_, _c_ образуют треугольник.

Проверку параметров _a_, _b_, _c_ проводить именно в таком порядке.

Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:

```python
a, b, c = map(int, input().split())
```

Затем, создайте объект _tr_ класса _TriangleChecker_ и передайте ему прочитанные значения _a_, _b_, _c_. Вызовите метод _is_triangle()_ из объекта _tr_ и выведите результат на экран (код, который она вернет).

## ex. 6. 
**Объявите класс _Graph_, объекты которого можно было бы создавать с помощью команды:**

```python
gr_1 = Graph(data)
```

где _data_ - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:

_data_ - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
_is_show_ - булево значение (_True/False_) для показа (_True_) и сокрытия (_False_) данных графика (по умолчанию _True_);

В этом классе объявите следующие методы:

_set_data(self, data)_ - для передачи нового списка данных в текущий график;

_show_table(self)_ - для отображения данных в виде строки из списка чисел (числа следуют через пробел);

_show_graph(self)_ - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
_show_bar(self)_ - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
_set_show(self, fl_show)_ - метод для изменения локального свойства _is_show_ на переданное значение _fl_show_.

Если локальное свойство _is_show_ равно _False_, то методы _show_table()_, _show_graph()_ и _show_bar()_ должны выводить сообщение:

```
"Отображение данных закрыто"
```
Прочитайте из входного потока числовые данные с помощью команды:
```python
data_graph = list(map(int, input().split()))
```

Создайте объект _gr_ класса _Graph_ с набором прочитанных данных, вызовите метод _show_bar()_, затем метод _set_show()_ со значением _fl_show = False_ и вызовите метод _show_table()_. На экране должны отобразиться две соответствующие строки.

## ex. 7. 
**Объявите в программе следующие несколько классов:**

_CPU_ - класс для описания процессоров;

_Memory_ - класс для описания памяти;

_MotherBoard_ - класс для описания материнских плат.


Обеспечить возможность создания объектов каждого класса командами:

```python
cpu = CPU(наименование, тактовая частота)
mem = Memory(наименование, размер памяти)
mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
```
Обратите внимание при создании объекта класса _MotherBoard_ можно передавать несколько объектов класса _Memory_, максимум _N_ - по числу слотов памяти на материнской плате (_N = 4_).

Объекты классов должны иметь следующие локальные свойства:

**для класса CPU:** _name_ - наименование; _fr_ - тактовая частота;

**для класса Memory:** _name_ - наименование; _volume_ - объем памяти;

**для класса MotherBoard:** _name_ - наименование; _cpu_ - ссылка на объект класса _CPU_; _total_mem_slots = 4_ - общее число слотов памяти (атрибут прописывается с этим значением и не меняется); _mem_slots_ - список из объектов класса _Memory_ (максимум _total_mem_slots = 4_ штук по максимальному числу слотов памяти).

Класс _MotherBoard_ должен иметь метод _get_config(self)_ для возвращения текущей конфигурации компонентов на материнской плате в виде следующего списка из четырех строк:
```
['Материнская плата: <наименование>',
'Центральный процессор: <наименование>, <тактовая частота>',
'Слотов памяти: <общее число слотов памяти>',
'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']
```
Создайте объект _mb_ класса _MotherBoard_ с одним _CPU_ (объект класса _CPU_) и двумя слотами памяти (объекты класса _Memory_).

## ex. 8. 
**Объявите в программе класс _Cart_ (корзина), объекты которого создаются командой:**

```python
cart = Cart()
```

Каждый объект класса _Cart_ должен иметь локальное свойство _goods_ - список объектов для покупки (объекты классов _Table_, _TV_, _Notebook_ и _Cup_). Изначально этот список должен быть пустым.

В классе Cart объявить методы:

**add(self, gd)** - добавление в корзину товара, представленного объектом _gd_;

**remove(self, indx)** - удаление из корзины товара по индексу _indx_;

**get_list(self)** - получение из корзины товаров в виде списка из строк:

```
['<наименовние_1>: <цена_1>',
'<наименовние_2>: <цена_2>',
...
'<наименовние_N>: <цена_N>']
```

Объявите в программе следующие классы для описания товаров:

_Table_ - столы;

_TV_ - телевизоры;

_Notebook_ - ноутбуки;

_Cup_ - кружки.

Объекты этих классов должны создаваться командой:

```python
gd = ИмяКласса(name, price)
```
Каждый объект классов товаров должен содержать локальные свойства:

**name** - наименование;

**price** - цена.

Создайте в программе объект _cart_ класса _Cart_. Добавьте в него два телевизора (_TV_), один стол (_Table_), два ноутбука (_Notebook_) и одну кружку (_Cup_). Названия и цены придумайте сами.

## ex. 9.
**Вам необходимо реализовать односвязный список (**не список языка Python, объекты в списке не хранить, а формировать связанную структуру, показанную на рисунке**) из объектов класса _ListObject_:**


Для этого объявите в программе класс _ListObject_, объекты которого создаются командой:
```python
obj = ListObject(data)
```

Каждый объект класса _ListObject_ должен содержать локальные свойства:

_next_obj_ - ссылка на следующий присоединенный объект (если следующего объекта нет, то _next_obj = None_);

_data_ - данные объекта в виде строки.

В самом классе _ListObject_ должен быть объявлен метод:

**link(self, obj)** - для присоединения объекта _obj_ такого же класса к текущему объекту _self_ (то есть, атрибут _next_obj_ объекта _self_ должен ссылаться на _obj_).

Прочитайте список строк из входного потока командой:
```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

Затем сформируйте односвязный список, в объектах которых (в атрибуте _data_) хранятся строки из списка _lst_in_ (первая строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса _ListObject_ должна ссылаться переменная _head_obj_.

## ex. 10. 
**Объявите два класса:**

**Cell** - для представления клетки игрового поля;

**GamePole** - для управления игровым полем, размером N x N клеток.

С помощью класса _Cell_ предполагается создавать отдельные клетки командой:

```python
c1 = Cell(around_mines, mine)
```

Здесь _around_mines_ - число мин вокруг данной клетки поля; _mine_ - булева величина (_True//False_), означающая наличие мины в текущей клетке. При этом, в каждом объекте класса _Cell_ должны создаваться локальные свойства:

_around_mines_ - число мин вокруг клетки (начальное значение _0_);

_mine_ - наличие/отсутствие мины в текущей клетке (_True//False_);

_fl_open_ - открыта/закрыта клетка - булево значение (_True//False_). Изначально все клетки закрыты (_False_).

С помощью класса _GamePole_ должна быть возможность создавать квадратное игровое поле с числом клеток _N x N_:
```python
pole_game = GamePole(N, M)
```

Здесь _N_ - размер поля; _M_ - общее число мин на поле. При этом, каждая клетка представляется объектом класса _Cell_ и все объекты хранятся в двумерном списке _N x N_ элементов - локальном свойстве _pole_ объекта класса _GamePole_.

В классе _GamePole_ должны быть также реализованы следующие методы:

_init()_ - инициализация поля с новой расстановкой _M_ мин (случайным образом по игровому полю, разумеется каждая мина должна находиться в отдельной клетке).


_show()_ - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается символ _#_; мина отображается символом _*_; между клетками при отображении ставить пробел).

При создании экземпляра класса _GamePole_ в его инициализаторе следует вызывать метод _init()_ для первоначальной инициализации игрового поля.

В классе _GamePole_ могут быть и другие вспомогательные методы.

Создайте экземпляр _pole_game_ класса _GamePole_ с размером поля _N = 10_ и числом мин _M = 12_.